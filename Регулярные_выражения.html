<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
        table,
        table * {
          border: 1px solid #000;
        }
      </style>
        <title>Регулярные выражения</title>
    </head>
    <span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">
        <a href="/media/vladimir/Games+/Python_books/HTML/help/0_Помощь_Python.html">Помощь_Python.html</a></span></span>

    <body style="background-color:white;margin:0 0 0 0px;padding: 5px;">
    <hr id="a">
    <span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">

        &nbsp&nbsp&nbsp&nbsp<a href="#a0">Простой поиск</a>&nbsp&nbsp&nbsp&nbsp<a href="#a1">Начало и конец строки</a>&nbsp&nbsp&nbsp&nbsp<a href="#a2">Символьный класс</a>&nbsp&nbsp&nbsp&nbsp<a href="#a3">выбор</a>&nbsp&nbsp&nbsp&nbsp<a href="#a4">Игнорирование различий в регистре символов</a>&nbsp&nbsp&nbsp&nbsp<a href="#a5">Границы слов</a>&nbsp&nbsp&nbsp&nbsp<a href="#a6">Необязательные элементы</a>&nbsp&nbsp&nbsp&nbsp<a href="#a7">Квантификаторы</a>&nbsp&nbsp&nbsp&nbsp<a href="#a8">Функции для работы с регулярками</a>&nbsp&nbsp&nbsp&nbsp<a href="#a9">Пример использования всех основных функций</a>&nbsp&nbsp&nbsp&nbsp<a href="#a10">Скобочные группы <code>(?:...)</code> и перечисления</a>&nbsp&nbsp&nbsp&nbsp<a href="#a11">Группирующие скобки <code>(...)</code> и <code>match</code>-объекты в питоне</a>&nbsp&nbsp&nbsp&nbsp<a href="#a12">Использование групп при заменаx</a>&nbsp&nbsp&nbsp&nbsp<a href="#a13">Шаблоны, соответствующие не конкретному тексту, а позиции</a>&nbsp&nbsp&nbsp&nbsp<a href="#a14">Прочие фичи</a>&nbsp&nbsp&nbsp&nbsp<a href="#a17">Специальные символы-таблица</a>
     <span style="font-size:20px;"><span style="font-family:arial,helvetica,sans-serif;">
    <li><p><a href="#a0">Простой поиск</a> </p></li>
    <li><p><a href="#a1">Начало и конец строки</a> - ^ и $.</p></li>
    <li><p><a href="#a2">Символьный класс</a> [] </p></li>
    <li><p><a href="#a3">Выбор</a> | </p></li>
    <li><p><a href="#a4">Игнорирование различий в регистре символов</a> re.IGNORECASE </p></li>
    <li><p><a href="#a5">Границы слов</a> \b </p></li>
    <li><p><a href="#a6">Необязательные элементы</a></p></li>
    <li><p><a href="#a7">Квантификаторы</a> * + ? {n,m} </p></li>
    <li><p><a href="#a8">Функции для работы с регулярками</a></p></li>
    <li><p><a href="#a9">Пример использования всех основных функций</a></p></li>
    <li><p><a href="#a10">Скобочные группы <code>(?:...)</code> и перечисления </a></p></li>
    <li><p><a href="#a11">Группирующие скобки <code>(...)</code> и <code>match</code>-объекты в питоне</a></p></li>
    <li><p><a href="#a12">Использование групп при заменаx</a></p></li>
    <li><p><a href="#a13">Шаблоны, соответствующие не конкретному тексту, а позиции</a></p></li>
    <li><p><a href="#a14">Прочие фичи</a></p></li>
    <li><p><a href="#a17">Специальные символы-таблица</a></p></li>


         </span></span>
<h2 id="a0">Простой поиск&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<span style="font-size:20px;"><span style="font-family:arial,helvetica,sans-serif;">

<div class="justify">&nbsp&nbsp&nbsp&nbspЕсли в регулярном выражении не используется ни один из десятка с лишним метасимволов, то оно фактически превращается в средство «простого поиска текста». Например, при поиске выражения <b>cat</b> будут найдены и выведены все строки файла, содержащие три стоящих подряд буквы c·a·t.</div>
<pre>
    <b>import re

    text = 'cat, locate, vacation'
    print(re.findall(r'cat', text))</b>

    выведет:
    <b>
    ['cat', 'cat', 'cat']</b></pre>

<div class="justify">&nbsp&nbsp&nbsp&nbspФункция<b> findall()</b>  модуля <b>re</b> возвращает все неперекрывающиеся совпадения шаблона pattern в строке string в виде списка строк или список кортежей. Строка сканируется слева направо, и совпадения возвращаются в найденном порядке.</div>
<pre>
    Синтаксис:
<b>
    import re
    re.findall(pattern, string, flags=0)</b>

Параметры:

    pattern - строка, шаблон регулярного выражения,
    string - строка для поиска,
    flags=0 - один или несколько флагов.

Возвращаемое значение:

    список совпадений.

Результат зависит от количества групп захвата в шаблоне:

    Если групп нет, то возвращается список строк, соответствующих всему шаблону.
    Если существует ровно одна группа, то возвращается список строк, соответствующих этой группе.
    Если присутствует несколько групп, то возвращается список кортежей строк, соответствующих группам.

Группы без захвата не влияют на форму результата.
    <b>
    import re

    # Подстроки.
    re.findall(r'me', 'somedomerome')
    # ['me', 'me', 'me']

    # Группы.
    re.findall(r'(so|do|ro)(me)', 'somedomerome')
    # [('so', 'me'), ('do', 'me'), ('ro', 'me')]</b>

</pre></span></span>
<h2 id="a1">Начало и конец строки&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<span style="font-size:20px;"><span style="font-family:arial,helvetica,sans-serif;">

<div class="justify">&nbsp&nbsp&nbsp&nbspВероятно, простейшими метасимволами являются ^ (крышка, циркумфлекс) и $ (доллар), представляющие соответственно начало и конец проверяемой строки. Как говорилось выше, регулярное выражение cat находит последовательность символов c·a·t в любом месте строки, но для выражения ^cat совпадение происходит лишь в том случае, если символы c·a·t находятся
в начале строки — ^ фактически привязывает совпадение (остальной части регулярного выражения) к началу строки. Аналогично, выражение cat$ находит символы c·a·t только в том случае, если они находятся в конце строки — например, если строка завершается словом scat.</div>
<pre>
    <b>import re

    text = 'cat, locate, vacation, scat'
    print(re.findall(r'^cat', text))
    print(re.findall(r'cat$', text))</b>

    Выведет:

    <b>['cat']
    ['cat']</b>

    </pre></span></span>
<h2 id="a2">Символьный класс&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2><br>
<h3>Совпадение с одним символом из нескольких возможных </h3>
<span style="font-size:20px;"><span style="font-family:arial,helvetica,sans-serif;">
<div class="justify">Допустим, необходимо найти строку «grey», которая также может быть записана в виде «gray». При помощи конструкции […], называемой символьным классом (character class), можно перечислить символы, которые могут находиться в данной позиции текста. Выражение <b>e</b> совпадает только с буквой <b>е</b>, выражение <b>a</b> совпадает только с буквой <b>а</b>, но регулярное выражение <b>ea</b> совпадает с любой из этих букв. Таким образом, выражение <b>gr[ea]y</b> означает: «Найти символ <b>g</b>, за которым следует <b>r</b>, за которым следует <b>e</b> или <b>a</b>, и все это завершается символом <b>y</b>.</div>
<pre>
    <b>import re

    text = 'cat, locate, vacation, scat, grey, gray'
    print(re.findall(r'gr[ea]y', text))</b>

    Выведет:

    <b>['grey', 'gray']</b></pre>

<div class="justify">&nbsp&nbsp&nbsp&nbspВ контексте символьного класса метасимвол символьного класса <b>‘-’</b> (дефис) обозначает интервал символов; так, выражение <b>[0-9]</b> и <b>[a-z]</b> обычно используются соответственно для поиска цифр и символов нижнего регистра.</div><br>
<div class="justify">&nbsp&nbsp&nbsp&nbspСимвольный класс может содержать несколько интервалов, поэтому класс <b>[0123456789abcdefABCDEF]</b> записывается в виде <b>[0-9a-fA-F]</b> (или <b>[A-Fa-f0-9]</b>, поскольку порядок перечисления роли не играет). Такое выражение пригодится при обработке шестнадцатеричных чисел. Интервалы также можно объединять с литералами: выражение <b>[0-9A-Z_!.?]</b> совпадает с цифрой, символом верхнего регистра, символом подчеркивания,  восклицательным знаком, точкой или вопросительным знаком.</div><br>
<div class="justify">&nbsp&nbsp&nbsp&nbspОбратите внимание: дефис выполняет функции метасимвола только внутри символьного класса — в остальных случаях он совпадает с обычным дефисом. Более того, даже в символьных классах дефис не всегда интерпретируется как метасимвол. Если дефис является первым символом, указанным в классе, он заведомо не может определять интервал и поэтому интерпретируется как литерал. Аналогично,вопросительный знак и точка в конце класса считаются метасимволами в контексте обычных регулярных выражений, но не в контексте класса. Таким образом, в классе <b>[0-9A-Z_!.?]</b> специальное значение имеют только два дефиса.</div><br><br>

    <h3>Инвертированные символьные классы</h3><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspЕсли вместо <b>[…]</b> используется запись <b>[^…]</b>, класс совпадает с любыми символами,не входящими в приведенный список. Например, <b>[^1-6]</b> совпадает с символом, не принадлежащим интервалу от 1 до 6. Префикс <b>^ </b>в каком-то смысле «инвертирует» список, вместо того чтобы перечислять символы, принадлежащие классу, вы перечисляете символы, не
входящие в него.</div><br>

    <h3>Один произвольный символ</h3><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspМетасимвол <b>.</b> (точка) представляет собой сокращенную форму записи для символьного класса, совпадающего с любым символом. Он применяется в тех случаях,когда в некоторых позициях регулярного выражения могут находиться произвольные символы. Допустим, надо найти дату, которая может быть записана в формате 19/16, 19-16 или даже 19.16.
   <pre><b>
    import re

    text = 'cat, _9locate, vacation, scat, grey?, gray 19.16 19-16 19/16'
    print(re.findall(r'..[-./]..', text))</b>

    Выведет:<b>
    ['19.16', '19-16', '19/16']</b></pre>

    <div class="scrollable-table"><table>
<thead>
<tr>
<th>Шаблон</th>
<th>Описание</th>
<th>Пример</th>
<th>Применяем к тексту</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>Один любой символ, кроме новой строки <code>\n</code>.</td>
<td><code>м.л.ко</code></td>
<td><u><font color="#007d5b">молоко</font></u>, <u><font color="#007d5b">малако</font></u>, <br>
И<u><font color="#007d5b">м0л0ко</font></u>Ихлеб</td>
</tr>

<tr>
<td><code>\d</code></td>
<td>Любая цифра. \d≈[0-9]. Вообще говоря, в <code>\d</code> включается всё, что в юникоде помечено как «цифра»</td>
<td><code>СУ\d\d</code></td>
<td><u><font color="#007d5b">СУ35</font></u>, <u><font color="#007d5b">СУ11</font></u>1, АЛ<u><font color="#007d5b">СУ14</font></u></td>
</tr>

<tr>
<td><code>\D</code></td>
<td>Любой символ, кроме цифры. \D≈[^0-9]</td>
<td><code>926\D123</code></td>
<td><u><font color="#007d5b">926)123</font></u>, 1<u><font color="#007d5b">926-123</font></u>4</td>
</tr>

<tr>
<td><code>\s</code></td>
<td>Любой пробельный символ (пробел, табуляция, конец строки и т.п.). \s≈[ \f\n\r\t\v] </td>
<td><code>бор\sода</code></td>
<td><u><font color="#007d5b">бор ода</font></u>, <u><font color="#007d5b">бор<br>
ода</font></u>, борода</td>
</tr>

<tr>
<td><code>\S</code></td>
<td>Любой непробельный символ</td>
<td><code>\S123</code></td>
<td><u><font color="#007d5b">X123</font></u>, <u><font color="#007d5b">я123</font></u>, <u><font color="#007d5b">!123</font></u>456, 1 + 123456</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>Любая буква (то, что может быть частью слова), а также цифры и <code>_</code>. \w≈[0-9a-zA-Zа-яА-ЯёЁ]. Вообще говоря, в <code>\w</code> включается всё, что в юникоде помечено как буква. Ещё много всего!</td>
<td><code>\w\w\w</code></td>
<td><u><font color="#007d5b">Год</font></u>, <u><font color="#007d5b">f_3</font></u>, <u><font color="#007d5b">qwe</font></u>rt</td>
</tr>

<tr>
<td><code>\W</code></td>
<td>Любая не-буква, не-цифра и не подчёркивание</td>
<td><code>сом\W</code></td>
<td><u><font color="#007d5b">сом!</font></u>, <u><font color="#007d5b">сом?</font></u> </td>
</tr>

<tr>
<td><code>[..]</code></td>
<td>Один из символов в скобках,<br>
а также любой символ из диапазона <code>a-b</code></td>
<td><code>[0-9][0-9A-Fa-f]</code></td>
<td><u><font color="#007d5b">12</font></u>, <u><font color="#007d5b">1F</font></u>, <u><font color="#007d5b">4B</font></u></td>
</tr>

<tr>
<td><code>[^..]</code></td>
<td>Любой символ, кроме перечисленных</td>
<td><code>&lt;[^&gt;]&gt;</code></td>
<td><u><font color="#007d5b">&lt;1&gt;</font></u>, <u><font color="#007d5b">&lt;a&gt;</font></u>, &lt;&gt;&gt;</td>
</tr>

<tr>
<td><code>[abc-], [-1]</code></td>
<td>если нужен минус, его нужно указать последним или первым</td>
<td></td>
<td></td>
</tr>

<tr>
<td>[*[(+\\\]\t]</td>
<td>внутри скобок нужно экранировать только <code>]</code> и <code>\</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Начало или конец слова (слева пусто или не-буква, справа буква и наоборот).<br>
В отличие от предыдущих соответствует позиции, а не символу</td>
<td><code>\bвал</code></td>
<td><u><font color="#007d5b">вал</font></u>, перевал, Перевалка</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>Не граница слова: либо и слева, и справа буквы,<br>
либо и слева, и справа НЕ буквы</td>
<td><code>\Bвал</code></td>
<td>пере<u><font color="#007d5b">вал</font></u>, вал, Пере<u><font color="#007d5b">вал</font></u>ка</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>\Bвал\B</code></td>
<td>перевал, вал, Пере<u><font color="#007d5b">вал</font></u>ка</td>
</tr>
</tbody>
</table></div>

<h2 id="a3">Выбор&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>

<h3>Одно из нескольких подвыражений</h3>

<div class="justify">&nbsp&nbsp&nbsp&nbspОчень удобный метасимвол <b>|</b> означает «или». Он позволяет объединить несколько регулярных выражений в одно,совпадающее с любым из выражений-компонентов.</div>
<div class="justify">&nbsp&nbsp&nbsp&nbspНапример, <b>Bob</b> и <b>Robert</b> — два разных выражения, a <b>Bob|Robert</b> — одно выражение, совпадающее с любой из этих строк. Подвыражения, объединенные этим способом, называются <b>альтернативами</b>.</div>
<pre><b>
    import re

    text = 'cat, _9locate, vacation, scat, grey?, gray 19.16 19-16 19/16'
    print(re.findall(r'grey|gray', text))</b>

    Выведет:<b>
    ['grey', 'gray']</b></pre>

    <h2 id="a4">Игнорирование различий в регистре символов&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>

<div class="justify">&nbsp&nbsp&nbsp&nbspРассматривая пример с почтовым ящиком, будет уместно представить концепцию поиска совпадения без учета регистра. Поля в заголовках сообщений электронной почты обычно начинаются с прописной буквы (например, «Subject» или «From»), однако стандарт в действительности допускает произвольное сочетание регистра символов, поэтому поля «DATE» и «from» тоже
допустимы. К сожалению, регулярное выражение из предыдущего раздела с такими полями не совпадет. Одно из возможных решений — заменить <b>From</b> выражением <b>[Ff][Rr][Oo][Mm]</b>, совпадающим с любым вариантом написания слова «from», но подобная конструкция выглядит по меньшей мере громоздко.</div><br>
<div class="justify">&nbsp&nbsp&nbsp&nbspВ регулярных выражениях Python для игнорирования различий в регистре символов используется флаг <b>"re.IGNORECASE"</b> (или <b>"re.I"</b>).</div><br>
<div class="justify">&nbsp&nbsp&nbsp&nbspНапример, если мы хотим найти все вхождения слова <b>"apple"</b> в строке, но игнорировать различия в регистре, мы можем использовать следующий код:</div>
<pre><b>
    import re

    text = "I have an APPLE, an Apple, and an apple in my basket."

    # Используем флаг re.IGNORECASE, чтобы игнорировать различия в регистре
    pattern = r"apple"
    matches = re.findall(pattern, text, re.IGNORECASE)

    print(matches)</b></pre>

<div class="justify">&nbsp&nbsp&nbsp&nbspВ этом примере мы передаем флаг <b>"re.IGNORECASE"</b> третьим аргументом функции <b>"re.findall()"</b>, чтобы игнорировать различия в регистре символов при поиске совпадений. В результате, вместо того, чтобы найти только слово <b>"apple"</b> в нижнем регистре, мы находим все вхождения <b>"apple"</b> в любом регистре в тексте:</div>
<pre>
    <b>['APPLE', 'Apple', 'apple']</b></pre>

<div class="justify">&nbsp&nbsp&nbsp&nbspФлаг "re.IGNORECASE" также может быть использован в других функциях регулярных выражений Python, таких как</div>
    <pre><b>"re.search()", "re.match()"</b> и т.д.</pre>


<h2 id="a5">Границы слов&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>

<div class="justify">&nbsp&nbsp&nbsp&nbspГраницы слов - это позиции между символами, где начинается и заканчивается слово. В регулярных выражениях Python границы слов обозначаются метасимволом <b>"\b"</b>.</div>
<pre>
Например, если мы хотим найти все вхождения слова "dog" в строке, мы можем использовать следующий код:
    <b>
    import re

    text = "The quick brown fox jumps over the lazy dog."

    # Используем метасимвол \b для поиска границ слова "dog"
    pattern = r"\bdog\b"
    matches = re.findall(pattern, text)

    print(matches)</b></pre>


<div class="justify">&nbsp&nbsp&nbsp&nbspВ этом примере мы использовали метасимвол <b>"\b"</b> для поиска границ слова <b>"dog"</b>. Регулярное выражение <b>"\bdog\b"</b> найдет только слово <b>"dog"</b>, но не найдет его в словах, таких как <b>"dogs"</b> или <b>"dogmatic</b>".</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspОбратите внимание, что метасимвол <b>"\b"</b> может также использоваться для поиска границы слова в начале или конце строки, например, <b>"\bword"</b> найдет слово <b>"word"</b> в начале строки, а <b>"word\b"</b> найдет его в конце строки.</div><br>
<div class="justify">&nbsp&nbsp&nbsp&nbspГраницы слов определяются как переход от символов, которые являются частью слова, к символам, которые не являются частью слова. Символы, не являющиеся частью слова, включают в себя пробелы, знаки препинания и другие специальные символы.</div>
<div class="justify">&nbsp&nbsp&nbsp&nbspВ общем случае, следующие символы могут использоваться для определения границ слов в регулярных выражениях Python:</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- пробелы: обычные пробелы, табуляции, переводы строк и другие пробельные символы</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- знаки препинания: точки, запятые, двоеточия, точки с запятой, восклицательные и вопросительные знаки, скобки и другие знаки препинания</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- символы конца строки (например, "\n")</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- символы начала строки (например, "^") и конца строки (например, "$")</div>

<h2 id="a6">Необязательные элементы&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>

<div class="justify">&nbsp&nbsp&nbsp&nbspВ регулярных выражениях Python можно использовать необязательные элементы, которые обозначаются символом <b>`?`</b>.</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspНеобязательный элемент означает, что предшествующий ему элемент может встретиться в строке ноль или один раз. То есть, выражение, содержащее необязательный элемент, будет соответствовать строкам, содержащим либо исходный элемент, либо его отсутствие.</div>

<div class="justify">&nbsp&nbsp&nbsp&nbspНапример, рассмотрим следующее регулярное выражение: `colou?r`. Оно будет соответствовать строкам, содержащим слово <b>"color"</b> или <b>"colour"</b>. Символ <b>`?`</b> означает, что буква <b>"u"</b> является необязательной - она может быть либо включена в слово, либо отсутствовать.</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspЕще один пример: регулярное выражение <b>https?`</b>` соответствует строкам, начинающимся с <b>"http"</b> или <b>https"</b>". Символ <b>`?`</b>
после буквы <b>"s"</b> означает, что <b>"s"</b> является необязательной - она может быть либо включена в строку, либо отсутствовать.</div>

<div class="justify">&nbsp&nbsp&nbsp&nbspНеобязательные элементы полезны в тех случаях, когда некоторые элементы в строке могут присутствовать или отсутствовать, и вы хотите сопоставлять оба варианта с помощью одного регулярного выражения.</div>


<h2 id="a7">Квантификаторы&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>

<div class="justify">&nbsp&nbsp&nbsp&nbspКвантификаторы в регулярных выражениях Python - это специальные символы, которые определяют, сколько раз предшествующий элемент может встречаться в строке.</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspВот несколько наиболее распространенных квантификаторов в регулярных выражениях Python:</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbsp- `*` - соответствует нулю или более вхождениям предшествующего элемента(сколько угодно).</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- `+` - соответствует одному или более вхождению предшествующего элемента(не меньше одного).</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- `?` - соответствует нулю или одному вхождению предшествующего элемента(допускается один).</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- `{n}` - соответствует ровно n вхождениям предшествующего элемента.</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- `{n,}` - соответствует n или более вхождениям предшествующего элемента(при этом {0,} соответствует '*', а {1,} - '+').</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- `{,n}` - соответствует  не более n вхождениям предшествующего элемента.</div>
<div class="justify">&nbsp&nbsp&nbsp&nbsp- `{n,m}` - соответствует от n до m вхождений предшествующего элемента(аналог {0,1} - '?').</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspНапример, регулярное выражение `a+` соответствует строкам, содержащим одну или более букв "a", а выражение `b{2,4}` соответствует строкам, содержащим от двух до четырех букв "b" подряд.</div><br>

<div class="justify">&nbsp&nbsp&nbsp&nbspКвантификаторы позволяют создавать более мощные и гибкие регулярные выражения, которые могут сопоставлять строки различной длины и содержания. Однако следует помнить, что квантификаторы могут приводить к неожиданным результатам, если они применяются неправильно, поэтому необходимо внимательно проверять и тестировать регулярные выражения перед
использованием в коде.</div>
<pre>
   <b> import re

    # Регулярное выражение для поиска дат в формате YYYY-MM-DD
    pattern = r"\d{4}-\d{2}-\d{2}"

    # Текст, в котором мы ищем даты
    text = "Today is 2023-05-10, tomorrow is 2023-05-11, and yesterday was 2023-05-09."

    # Используем метод findall для поиска всех вхождений регулярного выражения в тексте
    matches = re.findall(pattern, text)

    # Выводим найденные даты
    print(matches)</b>

    Выведет:
    <b>['2023-05-10', '2023-05-11', '2023-05-09']</b>
</pre>
<div class="justify">&nbsp&nbsp&nbsp&nbspВ данном примере мы используем квантификаторы <b>{4}, {2} и {2}</b>, чтобы определить формат даты в виде <b>YYYY-MM-DD</b>. Затем мы используем метод <b>findall</b> модуля <b>re</b>, чтобы найти все вхождения этого шаблона в тексте и вывести их на экран.</div>

<h3>Жадные(мажорные) и минорные(ленивые) квантификаторы</h3>

<div class="justify">&nbsp&nbsp&nbsp&nbspКвантификатор {n,m} -является жадним квантификатором. Он ищет наибольшее вхождение в последовательности:</div>
<pre><b>
    import re

    string = 'google, gooogle, goooooogle'
    pattern = 'o{2,5}'

    result = re.findall(pattern, string)
    print(result)</b>

    Выведет:
   <b>['oo', 'ooo', 'ooooo']</b>  - так для первого слова найдет два o, для второго найдет все 3, а для последнего max 5

    Для превращения {n,m} в ленивый квантификатор за ним ставят ?:

    import re

    string = 'google, gooogle, goooooogle'
    pattern = 'o{2,5}?'

    result = re.findall(pattern, string)
    print(result)

    Выведет:
   <b>['oo', 'oo', 'oo', 'oo', 'oo']</b>  - так для первого слова найдет 2 o, для второго найдет 2 о, а для последнего
три по 2 о.

Найдем слово google c любым количеством букв о:
<b>
    import re

    string = 'google, gooogle, goooooogle'
    pattern = 'go{2,}gle'

    result = re.findall(pattern, string)
    print(result)</b>

Выведет:
   <b>['google', 'gooogle', 'goooooogle']</b>

    Найдем слово google c не более 4-мя буквами о:
<b>
    import re

    string = 'google, gooogle, goooooogle'
    pattern = 'go{,4}gle'

    result = re.findall(pattern, string)
    print(result)</b>

Выведет:
   <b>['google', 'gooogle']</b>

</pre></span></span>
<div>&nbsp;&nbsp;&nbsp;&nbsp;В регулярных выражениях <b>.+</b> и <b>.+?</b> - это два разных квантификатора.<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;Квантификатор <b>.+</b> соответствует одному или более любому символу, который может повторяться несколько раз. Он является жадным квантификатором, что означает, что он будет пытаться захватить как можно больше символов, чтобы обеспечить соответствие всего выражения.<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;Например, выражение <b>a.+c</b> в строке <b>abcabcdac</b> соответствует <b>abcabcdac</b>, так как <b>.+</b> соответствует <b>bcabcd</b>.<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;Квантификатор <b>.+?</b> также соответствует одному или более любому символу, но он является ленивым квантификатором, что означает, что он будет захватывать как можно меньше символов, чтобы обеспечить соответствие всего выражения.<br><br>

&nbsp;&nbsp;&nbsp;&nbsp;Например, выражение <b>a.+?c</b> в строке <b>abcabcdac</b> соответствует <b>abc</b>, так как <b>.+?</b> соответствует только b</b>.<br><br>

Вот пример:</div>
<pre><b>
	import re

	text = 'abcabcdac'
	# Жадный квантификатор
	print(re.findall('a.+c', text))  # ['abcabcdac']
	# Ленивый квантификатор
	print(re.findall('a.+?c', text))  # ['abc']

</b></pre>
<div>&nbsp;&nbsp;&nbsp;&nbsp;В первом примере, используя жадный квантификатор <b>.+</b>, мы получаем весь текст от <b>a</b> до <b>c</b>, а во втором примере, используя ленивый квантификатор <b>.+?</b>, мы получаем только текст до первого вхождения <b>c.</b></div><br><br>
<div class="justify">&nbsp&nbsp&nbsp&nbspНесколько регулярных выражений можно склеивать между собой, чтобы сформировать новые выражения. Например, если A и B являются регулярными выражениями, тогда AB тоже является регулярным выражением.</div>

<div class="justify">&nbsp&nbsp&nbsp&nbspВ общем случае, если строка p подпадает под шаблон A, а другая строка q подпадает под шаблон B, то строка pq подпадёт под AB. Исключение составляют случаи, когда :</div>
<pre>
    1. A или B содержат условия;
    2. в A или B используются пограничные описатели (\b);
    3. A и/или B содержат нумерованные группы.</pre>

<h2 id="a8">Функции для работы с регулярками живут в модуле <code>re</code>. Основные функции: &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2></p><div class="scrollable-table"><table>
<thead>
<tr>
<th>Функция</th>
<th>Её смысл</th>
</tr>
</thead>

<tbody>
<tr>
<td>re.search(pattern, string)</td>
<td>Найти в строке <code>string</code> первую строчку, подходящую под шаблон <code>pattern</code>;</td>
</tr>

<tr>
<td>re.fullmatch(pattern, string)</td>
<td>Проверить, подходит ли строка <code>string</code> под шаблон <code>pattern</code>;</td>
</tr>

<tr>
<td>re.split(pattern, string, maxsplit=0)</td>
<td>Аналог <code>str.split()</code>, только разделение происходит по подстрокам, подходящим под шаблон <code>pattern</code>;</td>
</tr>

<tr>
<td>re.findall(pattern, string)</td>
<td>Найти в строке <code>string</code> все непересекающиеся шаблоны <code>pattern</code>;</td>
</tr>

<tr>
<td>re.finditer(pattern, string)</td>
<td>Итератор всем непересекающимся шаблонам <code>pattern</code> в строке <code>string</code> (выдаются <code>match</code>-объекты);</td>
</tr>

<tr>
<td>re.sub(pattern, repl, string, count=0)</td>
<td>Заменить в строке <code>string</code> все непересекающиеся шаблоны <code>pattern</code> на <code>repl</code>; </td>
</tr>

</tbody>
</table></div> 

<h2 id="a9">Пример использования всех основных функций&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre><code><b>
	import re 

	match = re.search(r'\d\d\D\d\d', r'Телефон 123-12-12') 
	print(match[0] if match else 'Not found') 
	# -> 23-12 
	match = re.search(r'\d\d\D\d\d', r'Телефон 1231212') 
	print(match[0] if match else 'Not found') 
	# -> Not found 

	match = re.fullmatch(r'\d\d\D\d\d', r'12-12') 
	print('YES' if match else 'NO') 
	# -> YES 
	match = re.fullmatch(r'\d\d\D\d\d', r'Т. 12-12') 
	print('YES' if match else 'NO') 
	# -> NO 

	print(re.split(r'\W+', 'Где, скажите мне, мои очки??!')) 
	# -> ['Где', 'скажите', 'мне', 'мои', 'очки', ''] 

	print(re.findall(r'\d\d\.\d\d\.\d{4}', 
	                 r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
	# -> ['19.01.2018', '01.09.2017'] 

	for m in re.finditer(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'): 
	    print('Дата', m[0], 'начинается с позиции', m.start()) 
	# -> Дата 19.01.2018 начинается с позиции 20 
	# -> Дата 01.09.2017 начинается с позиции 45 

	print(re.sub(r'\d\d\.\d\d\.\d{4}', 
	             r'DD.MM.YYYY', 
	             r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
	# -> Эта строка написана DD.MM.YYYY, а могла бы и DD.MM.YYYY </b>
</code></pre> <br/>
<br/>
<br/>
<h3>Тонкости экранирования в питоне (<code>'\\\\\\\\foo'</code>)</h3> <p> <br/>
Так как символ <code>\</code> в питоновских строках также необходимо экранировать, то в результате в шаблонах могут возникать конструкции вида <code>'\\\\par'</code>. Первый слеш означает, что следующий за ним символ нужно оставить «как есть». Третий также. В результате с точки зрения питона <code>'\\\\'</code> означает просто два слеша <code>\\</code>. Теперь с точки зрения движка регулярных выражений, первый слеш экранирует второй. Тем самым как шаблон для регулярки <code>'\\\\par'</code> означает просто текст <code>\par</code>. Для того, чтобы не было таких нагромождений слешей, перед открывающей кавычкой нужно поставить символ <code>r</code>, что скажет питону «не рассматривай \ как экранирующий символ (кроме случаев экранирования открывающей кавычки)». Соответственно можно будет писать <code>r'\\par'</code>. <br/>
<br/>

</p><h3>Использование дополнительных флагов в питоне</h3> <br>
Каждой из функций, перечисленных выше, можно дать дополнительный параметр <code>flags</code>, что несколько изменит режим работы регулярок. В качестве значения нужно передать сумму выбранных констант, вот они: <div class="scrollable-table"><table>
<thead>
<tr>
<th>Константа</th>
<th>Её смысл</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>re.ASCII</code></td>
<td>По умолчанию <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code>, <code>\S</code> соответствуют  все юникодные символы с соответствующим качеством. <br>Например, <code>\d</code> соответствуют не только арабские цифры, но и вот такие: ٠١٢٣٤٥٦٧٨٩. <br>
 <code>re.ASCII</code> ускоряет работу, если все соответствия лежат внутри ASCII.</td>
</tr>
<tr>
<td><nobr><code>re.IGNORECASE</code></nobr></td>
<td>Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно</td>
</tr>
<tr>
<td><code>re.MULTILINE</code></td>
<td>Специальные символы <code>^</code> и <code>$</code> соответствуют началу и концу каждой строки</td>
</tr>
<tr>
<td><code>re.DOTALL</code></td>
<td>По умолчанию символ <code>\n</code> конца строки не подходит под точку. <br>
 С этим флагом точка — вообще любой символ</td>
</tr>
</tbody>
</table></div> 
<pre>
Примеры:

<code>import re 
print(re.findall(r'\d+', '12 + ٦٧')) 

Получаем:

['12', '٦٧'] 
_______________________________________________________________________

print(re.findall(r'\w+', 'Hello, мир!')) 

Получаем:

['Hello', 'мир'] 
_______________________________________________________________________

print(re.findall(r'\d+', '12 + ٦٧', flags=re.ASCII)) 

Получаем:

['12'] 
_______________________________________________________________________

print(re.findall(r'\w+', 'Hello, мир!', flags=re.ASCII)) 

Получаем:

['Hello'] 
_______________________________________________________________________

print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя')) 

Получаем:

['ааааа', 'яяяя'] 
_______________________________________________________________________

print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя', flags=re.IGNORECASE)) 

Получаем:

['ОООО', 'ааааа', 'ЫЫЫЫ', 'яяяя'] 
_______________________________________________________________________

text = r&quot;&quot;&quot; 
Торт 
с вишней1 
вишней2 
&quot;&quot;&quot; 

print(re.findall(r'Торт.с', text)) 

Получаем:

[] 
_______________________________________________________________________

print(re.findall(r'Торт.с', text, flags=re.DOTALL)) 

Получаем:

['Торт\nс'] 
_______________________________________________________________________

print(re.findall(r'виш\w+', text, flags=re.MULTILINE)) 

Получаем:

['вишней1', 'вишней2'] 
_______________________________________________________________________

print(re.findall(r'^виш\w+', text, flags=re.MULTILINE)) 

Получаем:

['вишней2'] 
</code></pre><br>
 <br>

<h2 id="a10">Скобочные группы <code>(?:...)</code> и перечисления <code>|</code>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2> <br>

<h3>Перечисления (операция «ИЛИ»)</h3> <br>

<p>Чтобы проверить, удовлетворяет ли строка хотя бы одному из шаблонов, можно воспользоваться аналогом оператора <code>or</code>, который записывается с помощью символа <code>|</code>. Так, некоторая строка подходит к регулярному выражению <code>A|B</code> тогда и только тогда, когда она подходит хотя бы к одному из регулярных выражений <code>A</code> или <code>B</code>. Например, отдельные овощи в тексте можно искать при помощи шаблона <code>морковк|св[её]кл|картошк|редиск</code>. </p> <br>
<br>
<h3>Скобочные группы (группировка плюс квантификаторы)</h3> <p> <br>
Зачастую шаблон состоит из нескольких повторяющихся групп. Так, MAC-адрес сетевого устройства обычно записывается как шесть групп из двух шестнадцатиричных цифр, разделённых символами <code>-</code> или <code>:</code>. Например, <code>01:23:45:67:89:ab</code>. Каждый отдельный символ можно задать как <code>[0-9a-fA-F]</code>, и можно весь шаблон записать так: <br>
 <code>[0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}</code> </p><p>Ситуация становится гораздо сложнее, когда количество групп заранее не зафиксировано. <br>
Чтобы разрешить эту проблему в синтаксисе регулярных выражений есть группировка <code>(?:...)</code>. Можно писать круглые скобки и без значков <code>?:</code>, однако от этого у группировки значительно меняется смысл, регулярка начинает работать гораздо медленнее. Об этом будет написано ниже. Итак, если <code>REGEXP</code> — шаблон, то <code>(?:REGEXP)</code> — эквивалентный ему шаблон. Разница только в том, что теперь к <code>(?:REGEXP)</code> можно применять квантификаторы, указывая, сколько именно раз должна повториться группа. Например, шаблон для поиска MAC-адреса, можно записать так: <br>
 <code>[0-9a-fA-F]{2}(?:[:-][0-9a-fA-F]{2}){5}</code> <br>
<br>
<br>
</p>
<h3>Скобки плюс перечисления</h3> <p> <br>
Также скобки <code>(?:...)</code> позволяют локализовать часть шаблона, внутри которого происходит перечисление. Например, шаблон <code>(?:он|тот) (?:шёл|плыл)</code> соответствует каждой из строк «он шёл», «он плыл», «тот шёл», «тот плыл», и является синонимом <code>он шёл|он плыл|тот шёл|тот плыл</code>. </p> <br>
<br>
Ещё примеры 

<table>
<thead>
<tr>
<th>Шаблон</th>
<th>Применяем к тексту</th>
</tr>
</thead>

<tbody>
<tr>
<td>(?:\w\w\d\d)+</td>
<td>Есть м<u><font color="#007d5b">иг29</font></u>а, <u><font color="#007d5b">ту15</font></u>4б. Некоторые делают даже м<u><font color="#007d5b">иг29ту15</font></u>4<u><font color="#007d5b">ил86</font></u>.</td>
</tr>

<tr>
<td>(?:\w+\d+)+</td>
<td>Есть <u><font color="#007d5b">миг29</font></u>а, <u><font color="#007d5b">ту154</font></u>б. Некоторые делают даже <u><font color="#007d5b">миг29ту154ил86</font></u>.</td>
</tr>

<tr>
<td>(?:\+7|8)(?:-\d{2,3}){4}</td>
<td><u><font color="#007d5b">+7-926-123-12-12</font></u>, <u><font color="#007d5b">8-926-123-12-12</font></u></td>
</tr>

<tr>
<td>(?:[Хх][аоеи]+)+</td>
<td>Му<u><font color="#007d5b">ха</font></u> — <u><font color="#007d5b">хахахехо</font></u>, ну <u><font color="#007d5b">хааахооохе</font></u>, да <u><font color="#007d5b">хахахехохииии</font></u>! <u><font color="#007d5b">Ха</font></u>м трамвайный.</td>
</tr>

<tr>
<td>\b(?:[Хх][аоеи]+)+\b</td>
<td>Муха — <u><font color="#007d5b">хахахехо</font></u>, ну <u><font color="#007d5b">хааахооохе</font></u>, да <u><font color="#007d5b">хахахехохииии</font></u>! Хам трамвайный.</td>
</tr>
</tbody></table>

<br>
<h2 id="a11">Группирующие скобки <code>(...)</code> и <code>match</code>-объекты в питоне&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2> <br>
<br>
<h3>Match-объекты</h3> <br>
<p>Если функции <code>re.search</code>, <code>re.fullmatch</code> не находят соответствие шаблону в строке, то они возвращают <code>None</code>, функция <code>re.finditer</code> не выдаёт ничего. Однако если соответствие найдено, то возвращается <code>match</code>-объект. Эта штука содержит в себе кучу полезной информации о соответствии шаблону. Полный набор атрибутов можно посмотреть в <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow"> документации</a>, а здесь приведём самое полезное. </p>

<table>
<thead>
<tr>
<th>Метод</th>
<th>Описание</th>
<th>Пример</th>
</tr>
</thead>

<tbody>
<tr>
<td>match[0],<br>
match.group()</td>
<td>Подстрока, соответствующая шаблону</td>
<td>match = re.search(r'\w+', r'$$ What??')<br>
match[0]<br> Выведет: 'What'</td>
</tr>
<tr>
<td>match.start()</td>
<td>Индекс в исходной строке, начиная с которого идёт найденная подстрока</td>
<td>match = re.search(r'\w+', r'$$ What??')<br>
match.start() <br> Выведет: 3</td>
</tr>
<tr>
<td>match.end()</td>
<td>Индекс в исходной строке, который следует сразу за найденной подстрока</td>
<td>match = re.search(r'\w+', r'$$ What??')<br>
match.end() <br> Выведет: 7</td>
</tr>
</tbody>
</table></div> <br>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re01.png" alt="Just image"> <br>
<br>
<h3>Группирующие скобки <code>(...)</code></h3> <p> <br>
Если в шаблоне регулярного выражения встречаются скобки <code>(...)</code> без <code>?:</code>, то они становятся <em>группирующими</em>. В match-объекте, который возвращают <code>re.search</code>, <code>re.fullmatch</code> и <code>re.finditer</code>, по каждой такой группе можно получить ту же информацию, что и по всему шаблону. А именно часть подстроки, которая соответствует <code>(...)</code>, а также индексы начала и окончания в исходной строке. Достаточно часто это бывает полезно. </p> 
<pre>
<code>import re 
pattern = r'\s*([А-Яа-яЁё]+)(\d+)\s*' 
string = r'---   Опять45   ---' 
match = re.search(pattern, string) 
print(f'Найдена подстрока &gt;{match[0]}&lt; с позиции {match.start(0)} до {match.end(0)}') 
print(f'Группа букв &gt;{match[1]}&lt; с позиции {match.start(1)} до {match.end(1)}') 
print(f'Группа цифр &gt;{match[2]}&lt; с позиции {match.start(2)} до {match.end(2)}') 

Выведет: 
 Найдена подстрока &gt;   Опять45   &lt; с позиции 3 до 16 
 Группа букв &gt;Опять&lt; с позиции 6 до 11 
 Группа цифр &gt;45&lt; с позиции 11 до 13 
</code></pre><br>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re02.png" alt="Just image"> <br>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re03.png" alt="Just image"> <p> <br>
<br>
</p><h3>Тонкости со скобками и нумерацией групп.</h3> <p> <br>
Если к группирующим скобкам применён квантификатор (то есть указано число повторений), то подгруппа в match-объекте будет создана только для последнего соответствия. Например, если бы в примере выше квантификаторы были снаружи от скобок <code>'\s*([А-Яа-яЁё])+(\d)+\s*'</code>, то вывод был бы таким: </p>
<pre>
<code> Найдена подстрока &gt;   Опять45   &lt; с позиции 3 до 16 
 Группа букв &gt;ь&lt; с позиции 10 до 11 
 Группа цифр &gt;5&lt; с позиции 12 до 13 
</code></pre><p> <br>
Внутри группирующих скобок могут быть и другие группирующие скобки. В этом случае их нумерация производится в соответствии с номером появления открывающей скобки с шаблоне. </p>
<pre>
<code>import re 
pattern = r'((\d)(\d))((\d)(\d))' 
string = r'123456789' 
match = re.search(pattern, string) 
print(f'Найдена подстрока &gt;{match[0]}&lt; с позиции {match.start(0)} до {match.end(0)}') 
for i in range(1, 7): 
    print(f'Группа №{i} &gt;{match[i]}&lt; с позиции {match.start(i)} до {match.end(i)}') 

Выведет: 
 Найдена подстрока &gt;1234&lt; с позиции 0 до 4 
 Группа №1 &gt;12&lt; с позиции 0 до 2 
 Группа №2 &gt;1&lt; с позиции 0 до 1 
 Группа №3 &gt;2&lt; с позиции 1 до 2 
 Группа №4 &gt;34&lt; с позиции 2 до 4 
 Группа №5 &gt;3&lt; с позиции 2 до 3 
 Группа №6 &gt;4&lt; с позиции 3 до 4 
</code></pre><br>
<h3>Группы и <code>re.findall</code></h3> <p> <br>
Если в шаблоне есть группирующие скобки, то вместо списка найденных подстрок будет возвращён список кортежей, в каждом из которых только соответствие каждой группе. Это не всегда происходит по плану, поэтому обычно нужно использовать негруппирующие скобки <code>(?:...)</code>. </p>
<pre>
<code>import re 
print(re.findall(r'([a-z]+)(\d*)', r'foo3, im12, go, 24buz42'))

Выведет: 
 [('foo', '3'), ('im', '12'), ('go', ''), ('buz', '42')] 
</code></pre><br>
<br>
<h3>Группы и <code>re.split</code></h3> <p> <br>
Если в шаблоне нет группирующих скобок, то <code>re.split</code> работает очень похожим образом на <code>str.split</code>. А вот если группирующие скобки в шаблоне есть, то между каждыми разрезанными строками будут все соответствия каждой из подгрупп. </p>
<pre>
<code>import re 
print(re.split(r'(\s*)([+*/-])(\s*)', r'12  +  13*15   - 6')) 

Выведет:
 ['12', '  ', '+', '  ', '13', '', '*', '', '15', '   ', '-', ' ', '6'] 
</code></pre>
В некоторых ситуация эта возможность бывает чрезвычайно удобна! Например, достаточно из предыдущего примера убрать лишние группы, и польза сразу станет очевидна! 
<pre>
<code>import re 
print(re.split(r'\s*([+*/-])\s*', r'12  +  13*15   - 6'))

Выведет: 
 ['12', '+', '13', '*', '15', '-', '6'] 
</code></pre><br>
 <br>
 <br>
<h2 id="a12">Использование групп при заменах&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2> <p> <br>
Использование групп добавляет замене (<code>re.sub</code>, работает не только в питоне, а почти везде) очень удобную возможность: в шаблоне для замены можно ссылаться на соответствующую группу при помощи <code>\1, \2, \3, ...</code>. Например, если нужно даты из неудобного формата ММ/ДД/ГГГГ перевести в удобный ДД.ММ.ГГГГ, то можно использовать такую регулярку: </p>
<pre>
<code>import re 
text = &quot;We arrive on 03/25/2018. So you are welcome after 04/01/2018.&quot; 
print(re.sub(r'(\d\d)/(\d\d)/(\d{4})', r'\2.\1.\3', text)) 

Выведет:
 We arrive on 25.03.2018. So you are welcome after 01.04.2018. 
</code></pre>
<p> <br>
Если групп больше 9, то можно ссылаться на них при помощи конструкции вида <code>\g&lt;12&gt;</code>. </p> <br>
<br>
<h3>Замена с обработкой шаблона функцией в питоне</h3> 
<p> <br>
Ещё одна питоновская фича для регулярных выражений: в функции <code>re.sub</code> вместо текста для замены можно передать функцию, которая будет получать на вход match-объект и должна возвращать строку, на которую и будет произведена замена. Это позволяет не писать ад в шаблоне для замены, а использовать удобную функцию. Например, «зацензурим» все слова, начинающиеся на букву «Х»: </p>
<pre>
<code>import re 
def repl(m): 
    return '&gt;censored(' + str(len(m[0])) + ')&lt;' 
text = &quot;Некоторые хорошие слова подозрительны: хор, хоровод, хороводоводовед.&quot; 
print(re.sub(r'\b[хХxX]\w*', repl, text)) 

Выведет:
 Некоторые &gt;censored(7)&lt; слова подозрительны: &gt;censored(3)&lt;, &gt;censored(7)&lt;, &gt;censored(15)&lt;. 
</code></pre><br>
<br>
<h3>Ссылки на группы при поиске</h3> <p> <br>
При помощи <code>\1, \2, \3, ...</code> и <code>\g&lt;12&gt;</code> можно ссылаться на найденную группу и при поиске. Необходимость в этом встречается довольно редко, но это бывает полезно при обработке простых xml и html. </p> <p> <br>
Только пообещайте, что не будете парсить сложный xml и тем более html при помощи регулярок! Регулярные выражения для этого не подходят. Используйте другие инструменты. Каждый раз, когда неопытный программист парсит html регулярками, в мире умирает котёнок. Если кажется «Да здесь очень простой html, напишу регулярку», то сразу вспоминайте шутку про две проблемы. Не нужно пытаться парсить html регулярками, даже Пётр Митричев не сможет это сделать в общем случае :) Использование регулярных выражений при парсинге html подобно залатыванию резиновой лодки шилом. Закон Мёрфи для парсинга html и xml при помощи регулярок гласит: парсинг html и xml регулярками иногда работает, но в точности до того момента, когда правильность результата будет <em>очень</em> важна. </p> <p> <br>
Используйте <a href="http://lxml.de/" rel="nofollow">lxml</a> и <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" rel="nofollow">beautiful soup</a>. </p>
<pre>
<code>import re 
text = &quot;SPAM &lt;foo&gt;Here we can &lt;boo&gt;find&lt;/boo&gt; something interesting&lt;/foo&gt; SPAM&quot; 
print(re.search(r'&lt;(\w+?)&gt;.*?&lt;/\1&gt;', text)[0]) 

Выведет:
 &lt;foo&gt;Here we can &lt;boo&gt;find&lt;/boo&gt; something interesting&lt;/foo&gt; 
text = &quot;SPAM &lt;foo&gt;Here we can &lt;foo&gt;find&lt;/foo&gt; OH, NO MATCH HERE!&lt;/foo&gt; SPAM&quot; 
print(re.search(r'&lt;(\w+?)&gt;.*?&lt;/\1&gt;', text)[0]) 

Выведет:
 &lt;foo&gt;Here we can &lt;foo&gt;find&lt;/foo&gt; 
</code></pre><br>
 <br>
<h2 id="a13">Шаблоны, соответствующие не конкретному тексту, а позиции&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2> <p> <br>
Отдельные части регулярного выражения могут соответствовать не части текста, а позиции в этом тексте. То есть такому шаблону соответствует не подстрока, а некоторая позиция в тексте, как бы «между» буквами. </p> <br>
<br>
<h3>Простые шаблоны, соответствующие позиции</h3> <br>
Для определённости строку, в которой мы ищем шаблон будем называть <em>всем текстом</em>.Каждую строчку <em>всего текста</em> (то есть каждый максимальный кусок без символов конца строки) будем называть <em>строчкой текста</em>.
<table>
<thead>
<tr>
<th>Шаблон</th>
<th>Описание</th>
<th>Пример</th>
<th>Применяем к тексту</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>Начало всего текста или начало строчки текста,<br>
если <code>flag=re.MULTILINE</code></td>
<td><code>^Привет</code></td>
<td></td>
</tr>
<tr>
<td><code>$</code></td>
<td>Конец всего текста или конец строчки текста,<br>
если <code>flag=re.MULTILINE</code></td>
<td><code>Будь здоров!$</code></td>
<td></td>
</tr>
<tr>
<td><code>\A</code></td>
<td>Строго начало всего текста</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\Z</code></td>
<td>Строго конец всего текста</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Начало или конец слова (слева пусто или не-буква, справа буква и наоборот)</td>
<td><code>\bвал</code></td>
<td><u><font color="#007d5b">вал</font></u>, перевал, Перевалка</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>Не граница слова: либо и слева, и справа буквы,<br>
либо и слева, и справа НЕ буквы</td>
<td><code>\Bвал</code></td>
<td>пере<u><font color="#007d5b">вал</font></u>, вал, Пере<u><font color="#007d5b">вал</font></u>ка</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>\Bвал\B</code></td>
<td>перевал, вал, Пере<u><font color="#007d5b">вал</font></u>ка</td>
</tr>
</tbody>
</table></div>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re04.png" alt="Just image"> <br>
<h3>Сложные шаблоны, соответствующие позиции (<em>lookaround</em> и Co)</h3> <br>
<p>Следующие шаблоны применяются в основном в тех случаях, когда нужно уточнить, что должно идти непосредственно перед или после шаблона, но при этом <br>
не включать найденное в match-объект. </p><div class="scrollable-table"><table>
<thead>
<tr>
<th>Шаблон</th>
<th>Описание</th>
<th>Пример</th>
<th>Применяем к тексту</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(?=...)</code></td>
<td><em>lookahead assertion</em>, соответствует каждой <br>
 позиции, сразу после которой начинается <br>
соответствие шаблону ...</td>
<td><code>Isaac (?=Asimov)</code></td>
<td><u><font color="#007d5b">Isaac </font></u>Asimov, Isaac other</td>
</tr>
<tr>
<td><code>(?!...)</code></td>
<td><em>negative lookahead assertion</em>, соответствует <br>
каждой позиции, сразу после которой <br>
НЕ может начинаться шаблон ...</td>
<td><code>Isaac (?!Asimov)</code></td>
<td>Isaac Asimov, <u><font color="#007d5b">Isaac </font></u>other</td>
</tr>
<tr>
<td><code>(?&lt;=...)</code></td>
<td><em>positive lookbehind assertion</em>, соответствует <br>
каждой позиции, которой может заканчиваться шаблон ...<br>
Длина шаблона должна быть фиксированной, <br>
то есть <code>abc</code> и <code>a|b</code> — это ОК, а <code>a*</code> и <code>a{2,3}</code> — нет.</td>
<td><code>(?&lt;=abc)def</code></td>
<td>abc<u><font color="#007d5b">def</font></u>, bcdef</td>
</tr>
<tr>
<td><nobr><code>(?&lt;!...)</code></nobr></td>
<td><em>negative lookbehind assertion</em>, соответствует <br>
каждой позиции, которой НЕ может <br>
заканчиваться шаблон ...</td>
<td><code>(?&lt;!abc)def</code></td>
<td>abcdef, bc<u><font color="#007d5b">def</font></u></td>
</tr>
</tbody>
</table></div>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re05.png" alt="Just image">
<p>На всякий случай ещё раз. Каждый их этих шаблонов проверяет лишь то, что идёт непосредственно перед позицией или непосредственно после позиции. Если пару таких шаблонов написать рядом, то проверки будут независимы (то есть будут соответствовать AND в каком-то смысле). <br>
<br>
</p><h3>lookaround на примере королей и императоров Франции</h3> <p><br>
<code>Людовик(?=VI)</code> — Людовик, за которым идёт VI<br>
</p><blockquote>КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII, <br>
ЛюдовикIX, <font color="#00FFDD"><u>Людовик</u></font>VI, <font color="#00FFDD"><u>Людовик</u></font>VII, <font color="#00FFDD"><u>Людовик</u></font>VIII, ЛюдовикX, ..., ЛюдовикXVIII, <br>
ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI<br>
</blockquote><br>
<code>Людовик(?!VI)</code> — Людовик, за которым идёт не VI<br>
<blockquote>КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII, <br>
<font color="#00FFDD"><u>Людовик</u></font>IX, ЛюдовикVI, ЛюдовикVII, ЛюдовикVIII, <font color="#00FFDD"><u>Людовик</u></font>X, ..., <font color="#00FFDD"><u>Людовик</u></font>XVIII, <br>
ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI<br>
</blockquote><br>
<code>(?&lt;=Людовик)VI</code> — «шестой», но только если Людовик<br>
<blockquote>КарлIV, КарлIX, КарлV, КарлVI, КарлVII, КарлVIII, <br>
ЛюдовикIX, Людовик<font color="#00FFDD"><u>VI</u></font>, Людовик<font color="#00FFDD"><u>VI</u></font>I, Людовик<font color="#00FFDD"><u>VI</u></font>II, ЛюдовикX, ..., ЛюдовикXVIII, <br>
ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, ФилиппVI<br>
</blockquote><br>
<code>(?&lt;!Людовик)VI</code> — «шестой», но только если не Людовик<br>
<blockquote>КарлIV, КарлIX, КарлV, Карл<font color="#00FFDD"><u>VI</u></font>, Карл<font color="#00FFDD"><u>VI</u></font>I, Карл<font color="#00FFDD"><u>VI</u></font>II, <br>
ЛюдовикIX, ЛюдовикVI, ЛюдовикVII, ЛюдовикVIII, ЛюдовикX, ..., ЛюдовикX<font color="#00FFDD"><u>VI</u></font>II, <br>
ФилиппI, ФилиппII, ФилиппIII, ФилиппIV, ФилиппV, Филипп<font color="#00FFDD"><u>VI</u></font><br>
</blockquote><br>
<br>
<table>
<thead>
<tr>
<th>Шаблон</th>
<th>Комментарий</th>
<th>Применяем к тексту</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>(?&lt;!\d)\d(?!\d)</code></td>
<td>Цифра, окружённая не-цифрами</td>
<td>Text ABC 123 A<u><font color="#007d5b">1</font></u>B<u><font color="#007d5b">2</font></u>C<u><font color="#007d5b">3</font></u>!</td>
</tr>

<tr>
<td><code>(?&lt;=#START#).*?(?=#END#)</code></td>
<td>Текст от #START# до #END#</td>
<td>text from #START#<u><font color="#007d5b"> till </font></u>#END#</td>
</tr>

<tr>
<td><code>\d+(?=_(?!_))</code></td>
<td>Цифра, после которой идёт ровно одно подчёркивание</td>
<td><u><font color="#007d5b">12</font></u>_34__56</td>
</tr>

<tr>
<td><code>^(?:(?!boo).)*?$</code></td>
<td>Строка, в которой нет boo <br>
(то есть нет такого символа, <br>
перед которым есть boo)</td>
<td><u><font color="#007d5b">a foo and</font></u><br>
boo and zoo<br>
<u><font color="#007d5b">and others</font></u></td>
</tr>

<tr>
<td><code>^(?:(?!boo)(?!foo).)*?$</code></td>
<td>Строка, в которой нет ни boo, ни foo</td>
<td>a foo and <br>
boo and zoo <br>
<u><font color="#007d5b">and others</font></u></td>
</tr>
</tbody>
</table>
 <br>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re06.png" alt="Just image"> <br>
<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/re07.png" alt="Just image"> <br>
 <br>
<h2 id="a14">Прочие фичи&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2> <p> <br>
Конечно, здесь описано не всё, что умеют регулярные выражения, и даже не всё, что умеют регулярные выражения в питоне. Из полезного за кадром осталась компиляция регулярок для ускорения многократного использования одного шаблона, использование именных групп и разные хитрые трюки. <br>
 А уж какие извращения можно делать с регулярными выражениями в языке Perl — поручик Ржевский просто отдыхает :)<br>






<h2 id="a17">Специальные символы&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<br>
<br>

<table>
    <tbody>
    <tr><td></td><td><b>"Базовые</b></td></tr>
    <tr><td><code>\</code></td><td>Либо экранирует специальные символы, либо указывает на использование специальной последовательности (см. ниже). <b>Помните:</b> в Питоне обратный слеш тоже используется для экранирования в строковых литералах, поэтому зачастую в шаблонах рекомендуется использовать <i>сырые строки</i> (с префиксом <code>r</code>), которые не требуют экранирования.</td></tr>
    <tr><td><code>.</code></td><td>По умолчанию описывает любой символ, кроме перевода строки. С флагом <code>DOTALL</code> — также и перевод строки.</td></tr>
    <tr><td><code>^</code></td><td>Начало строки. С флагом <code>MULTILINE</code> — начало каждой из строк.</td></tr>
    <tr><td><code>$</code></td><td>Завершение строки. С флагом <code>MULTILINE</code> — завершение каждой из строк.</td></tr>
    <tr><td><code>x|y</code></td><td>Описывает первое подходящее из указанных выражений <code>x</code> или <code>y</code>. При помощи <code>|</code> можно соединить и более двух выражений.</td></tr>
    <tr><td><code>[]</code></td><td>Описывает указанное в скобках множество допустимых символов. <i>Специальные символы внутри множества не работают.</i> Поддерживаются диапазоны, например: <code>[a-z]</code>, <code>[Н-Я]</code>, <code>[0-8]</code>. Описатели классов символов допускаются, но зависят от режима интерпретации выражения (<code>ASCII</code>, либо <code>LOCALE</code>). Описать символы не входящие в указанное множество можно при помощи <code>^</code> после открывающей скобки, например: <code>[^abc]</code>, <code>[^\d]</code>. Чтобы включить символ <code>]</code> во множество, его можно либо указать непосредственно после открывающей скобки, либо экранировать при помощи <code>\</code>.</td></tr>
    <tr><td></td><td></td></tr>
    <tr><td></td><td><b>Специальные последовательности</b> (начинаются с обратного слеша — <code>\</code>)</td></tr>
    <tr><td><code>\num</code></td><td>Где <code>num</code> — число (от 1 до 99). Ссылается на группу указанную при помощи её порядкового номера. Под группой с индексом <code>0</code> обычно понимается обнаруженная строка в целом.</td></tr>
    <tr><td><code>\A</code></td><td>Пустая строка в начале строки.</td></tr>
    <tr><td><code>\b</code></td><td>Пограничная пустая строка (в начале или конце слова). Определение слова может зависеть от текущей локали. <b>Внимание:</b> в диапазонах символизирует возврат на символ (backspace).</td></tr>
    <tr><td><code>\B</code></td><td>Пустая строка не в начале и не в конце слова (т.е. обычно внутри слова).</td></tr>
    <tr><td><code>\d</code></td><td>Описывает десятичную цифру. Для Юникода — это символы категории <code>[Nd]</code>, для ASCII и байт — это то же, что и <code>[0-9]</code>.</td></tr>
    <tr><td><code>\D</code></td><td>Нецифровой символ.</td></tr>
    <tr><td><code>\s</code></td><td>Пробельные символы. Для ASCII — то же, что и <code>[ \t\n\r\f\v]</code>, для Юникода включает дополнительные символы, например неразрывный пробел.</td></tr>
    <tr><td><code>\S</code></td><td>Непробельные символы.</td></tr>
    <tr><td><code>\w</code></td><td>Символы, которые могут входить в состав слов, включая числа и подчёркивание. Для ASCII и байт — то же, что и <code>[a-zA-Z0-9_]</code>.</td></tr>
    <tr><td><code>\W</code></td><td>Несловарные символы.</td></tr>
    <tr><td><code>\Z</code></td><td>Пустая строка в конце строки.</td></tr>
    <tr><td></td><td></td></tr>
    <tr><td></td><td><b>Количественные описатели</b></td></tr>
    <tr><td><code>*</code></td><td>0 и более повторений предшествующего выражения.</td></tr>
    <tr><td><code>+</code></td><td>1 и более повторений предшествующего выражения.</td></tr>
    <tr><td><code>?</code></td><td>0 или 1 повторение предшествующего выражения.</td></tr>
    <tr><td><code>{x}</code></td><td><code>x</code> (число) повторений предшествующего выражения.</td></tr>
    <tr><td><code>{x,y}</code></td><td>От <code>x</code> до <code>y</code> повторений предшествующего выражения. Если опустить <code>x</code>, то предполагается 0; если опустить <code>y</code>, то предполагается неопределённое количество (запятую при этом опускать нельзя).</td></tr>
    <tr><td><small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/3.11/">3.11</a></div></small> <code>{x,y}+</code></td><td>Притяжательные количественные описатели. Сравните: под <code>a{3,5}aa</code> подпадает <code>aaaaaa</code> (под <code>a{3,5}</code> подходят первые 4 символа), в то время как при использовании <code>a{3,5}+aa</code> соответствие найдено не будет (найдутся пять символов, но за ними не будет <code>aa</code>. <code>x{m,n}+</code> то же, что и <code>(?&gt;x{m,n})</code>.</td></tr>
    <tr><td><code>*?</code>, <code>+?</code>, <code>??</code>, <code>{x,y}?</code></td><td>Добавление <code>?</code> к указанным описателям делает их нежадными, т.е. они станут описывать как можно меньшее количество символов. Сравните: под <code> &lt;.+&gt; </code> подпадёт вся строка <code> &lt;x&gt;b&lt;y&gt; </code>, в то время, как под <code> &lt;.+?&gt; </code> — только <code> &lt;x&gt; </code>.</td></tr>
    <tr><td><small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/3.11/">3.11</a></div></small> <code>*+</code>, <code>++</code>, <code>?+</code></td><td>Притяжательные количественные описатели. Сравните: под <code>a<i>a</i></code><i> подпадает <code>aaaa</code> (под <code>a</code></i> подходят первые три символа), в то время как при использовании <code>a<i>+a</i></code><i> соответствие найдено не будет (под <code>a</code></i> подходят все четрые символа, но за ними нет ещё одной <code>a</code>). <code>x*+</code>, <code>x++</code>, <code>x?+</code> то же что и <code>(?&gt;x*)</code>, <code>(?&gt;x+)</code>, <code>(?&gt;x?)</code> соответственно.</td></tr>
    <tr><td></td><td></td></tr><tr><td></td><td><b>Группировка</b></td></tr><tr><td><code>(x)</code></td><td>Задаёт группу, в которую должно попасть выражение <code>x</code>, к которой можно обращаться в дальнейшем по индексу — <code>\1</code> (если группа имеет номер 1).</td></tr><tr><td><code>(?P&lt;name&gt;x)</code></td><td>Задаёт группу с именем <code>name</code>, в которую должно попасть выражение <code>x</code>. Групп в дальнейшем можно адресовать как по указанному имени, так и по индексу  — <code>(?P=name)</code> или <code>\1</code> (если группа имеет номер 1).</td></tr>
    <tr><td><code>(?:x)</code></td><td>Задаёт группу, в которую должно попасть выражение <code>x</code>, к которой нельзя будет обратиться в дальнейшем ни по индексу, ни по имени.</td></tr>
    <tr><td><code>(?#...)</code></td><td>Комментарий. При разборе выражения будет проигнорирован.</td></tr>
    <tr><td></td><td></td></tr><tr><td></td><td><b>Условия</b></td></tr><tr><td><code>x(?=y)</code></td><td>Описывает выражение <code>x</code> только если за ним следует <code>y</code>. Например: <code>маршал (?=Жуков)</code> обнаружит <code>маршал </code> в строке <code>маршал Жуков</code>, но не в <code>маршал Конев</code>.</td></tr>
    <tr><td><code>x(?!y)</code></td><td>Описывает выражение <code>x</code> только если за ним не следует <code>y</code>. Например: <code>маршал (?!Жуков)</code> обнаружит <code>маршал </code> в строке <code>маршал Конев</code>, но не в <code>маршал Жуков</code>.</td></tr>
    <tr><td><code>x(?&lt;=y)</code></td><td>Описывает выражение <code>y</code> только если ему предшествует <code>x</code>. Например: <code>(?&lt;=маршал) Жуков</code> обнаружит <code> Жуков</code> в строке <code>маршал Жуков</code>, но не в <code>капитан Жуков</code>. <b>Внимание:</b> использование количественных описателей не поддерживается, требуются строки фиксированной длины.</td></tr>
    <tr><td><code>x(?&lt;!y)</code></td><td>Описывает выражение <code>y</code> только если ему не предшествует <code>x</code>. Например: <code>(?&lt;!маршал) Жуков</code> обнаружит <code> Жуков</code> в строке <code>капитан Жуков</code>, но не в <code>маршал Жуков</code>. <b>Внимание:</b> использование количественных описателей не поддерживается, требуются строки фиксированной длины.</td></tr>
    <tr><td><small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/2.4/">2.4</a></div></small> <code>(?(g)y|n)</code></td><td>Если группа <code>g</code> обнаружена, то описывает выражение <code>y</code>, иначе — выражение <code>n</code>. Например: под <code>(?P&lt;is_comrade&gt;товарищ)?(?(is_comrade) и брат|тамбовский волк)</code> подпадают строки <code>товарищ и брат</code> и <code>тамбовский волк</code>.</td></tr>
    <tr><td></td><td></td></tr><tr><td></td><td><b>Управление интерпретацией</b></td></tr><tr><td><code>(?aiLmsux)</code></td><td>Позволяет задать флаги интерпретации всего выражения без передачи параметра <i>flag</i> функциям. Значения символов: <code>a</code> — только ASCII; <code>i</code> — игнорировать регистр; <code>L</code> — использовать локаль; <code>m</code> — многострочный режим; <code>s</code> — точка обозначает любой символ; <code>u</code> — Юникод; <code>x</code> — дозволить описания в выражении.</td></tr>
    <tr><td><small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/3.6/">3.6</a></div></small> <code>(?aiLmsux-imsx:...)</code></td><td>Позволяет задать флаги интерпретации указанного выражения. После минуса можно указать флаги, которые требуется сбросить.  <code>a</code>, <code>L</code>, <code>u</code> — взаимоисключающие,</td></tr>
    </tbody>
</table>
<br>
<br>
Флаги интерпритации
<br><br>
    <table>
        <tbody>
        <tr><td><small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/3.0/">3.0</a></div></small> <code>re.A</code>, <code>re.ASCII</code></td><td>Если установлен, то <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> и <code>\S</code> описывают только ASCII символы, а не Юникод. <b>Внимание:</b> для байтовых шаблонов не используется.</td></tr>
        <tr><td><code>re.DEBUG</code></td><td>Выводить отладочную информацию о скомпилированном выражении.</td></tr><tr><td><code>re.I</code>, <code>re.IGNORECASE</code></td><td>Игнорировать регистр символов. Текущая локаль не влияет на работу, покуда не проставлен <code>re.LOCALE</code>.</td></tr>
        <tr><td><code>re.L</code>, <code>re.LOCALE</code></td><td>Если установлен, то <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> будут ориентироваться на настройки текущей локали. <b>Рассчитан на работу с байтами.</b> В <small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/3.0/">3.0</a></div></small> использование не рекомендуется — работа с Юникодом даёт более надёжные результаты.</td></tr>
        <tr><td><code>re.M</code>, <code>re.MULTILINE</code></td><td>Многострочный режим. Если установлен, то <code>^</code> и <code>$</code> будут находить начало и конец соответственно для каждой строки, включая переводы строк. В про время как по умолчанию на переводы строк указанные описатели не реагируют.</td></tr>
        <tr><td><code>re.S</code>, <code>re.DOTALL</code></td><td>Если установлен, то <code>.</code> обозначает любой символ, включая перевод строки.</td></tr>
        <tr><td><small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/2.0/">2.0</a></div></small> <code>re.U</code>, <code>re.UNICODE</code></td><td>Если установлен, то <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> и <code>\S</code> описывают символы Юникода. <b>Внимание:</b> для <small><div class="badge badge-info" title="Актуально с версии"><a href="/versions/named/3.0/">3.0</a></div></small> это режим по умолчанию.</td></tr>
        <tr><td><code>re.X</code>, <code>re.VERBOSE</code></td><td>Дозволяет описания в регулярных выражениях. Благодаря описаниям иногда шаблоны становятся более читаемыми. Описание можно поместить прямо в шаблон, начав его с <code>#</code>, при этом неэкранированные пробелы в шаблоне игнорируются.</td></tr>
        </tbody>
    </table>


    </body>
</html>