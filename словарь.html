<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <style>
    table,
    table * {
      border: 1px solid #000;
    }
  </style>
    <title>Словари</title>
</head>
<body>
<span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">
        <a href="./0_Помощь_Python.html">Помощь_Python.html</a></span></span>
  <hr>

<hr id="a">
    <span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">

        &nbsp&nbsp&nbsp&nbsp<a href="#a0">создание словаря</a>,&nbsp&nbsp<a href="#a1">создание словоря со списка кортежей(кортежа списков)</a>,&nbsp&nbsp<a href="#a2">cоздание словаря при помощи функции zip()</a>,
        &nbsp&nbsp<a href="#a3">создание словоря с дефолтными значениями при помощи fromkeys()</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a5">get()</a>,&nbsp&nbsp<a href="#a6">получение значения по ключу, проверка ключа</a>,
        &nbsp&nbsp<a href="#a4">сравнение словарей</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a7">sum(), min(), max()</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a8">удаление элементов словаря по функции del</a>,
        &nbsp&nbsp&nbsp&nbsp<a href="#a9">pop()</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a91">popitem()</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a10">даление всех элементов словаря</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a11">копирование словаря</a>,
        &nbsp&nbsp&nbsp&nbsp<a href="#a12">объединение словарей</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a13">key(), value(), item()</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a14">сортировка</a>,
		&nbsp&nbsp&nbsp&nbsp<a href="#a15">комплексные словари</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a16">setdefault()</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a18">генераторы словарей</a>,&nbsp&nbsp&nbsp&nbsp<a href="#a17">примечание</a></span></span>
        </hr>
<h2>Операции над словарями</h2>
    <span style="font-size:20px;"><span style="font-family:arial,helvetica,sans-serif;">
    <li><p><a href="#a0">dict1={}</a> - создание словаря.</p></li>
	<li><p><a href="#a1">dict(list) dict(tuple)</a> - создание словаря со списков или кортежей</p></li>
	<li><p><a href="#a7">sum(), min(), max()</a> - нахождение суммы и мин, макс значения ключей</p></li>
	<li><p><a href="#a2">dict(zip(keys, values))</a> - cоздание словаря при помощи функции zip()</p></li>
	<li><p><a href="#a3">dict.fromkeys()</a> - cоздание словаря со значниями по умолчанию</p></li>
	<li><p><a href="#a4">== и !=</a> - сравнение словарей по ключам и значениям</p></li>
	<li><p><a href="#a6">dict[], in </a> - получение значения по ключу, проверка ключа</p></li>
	<li><p><a href="#a5">get()</a> - доступ к элементу по функции get()</p></li>
	<li><p><a href="#a8">del dict()</a> - удаление элементов словаря по функции del</p></li>
	<li><p><a href="#a9">pop()</a> - удаление элементов словаря по функции pop()</p></li>
	<li><p><a href="#a91">popitem()</a> - удаление элементов словаря по функции popitem()</p></li>
	<li><p><a href="#a10">clear()</a> - удаление всех элементов словаря</p></li>
	<li><p><a href="#a11">copy(), deepcopy()</a> - копирование словаря</p></li>
	<li><p><a href="#a12">update(), |, |=, {**dict1, **dict2}</a> - объединение словарей</p></li>
	<li><p><a href="#a13">key(), value(), item()</a> - перебор словаря</p></li>
	<li><p><a href="#a14">sorted()</a> - сортировка</p></li>
	<li><p><a href="#a15">dict{dict1, ..., dictn}</a> - комплексные словари</p></li>
	<li><p><a href="#a16">setdefault()</a> - получение значения или добовление при отсутствии</p></li>
	<li><p><a href="#a18">{...}</a> - Генераторы словарей</p></li>
	<li><p><a href="#a17">!!!</a> - Примечание</p></li>
	</span></span>
	
<h2 id="a0">Словари</h2>
<span style="font-size:20px;"><span style="font-family:arial,helvetica,sans-serif;">

<p>Словарь (dictionary) в языке Python хранит коллекцию элементов, где каждый элемент имеет уникальный ключ и ассоциированое с ним некоторое значение.</p>
<p>Определение словаря имеет следующий синтаксис:</p>
<pre>
	dictionary = { ключ1:значение1, ключ2:значение2, ....}
</pre>
<p>В фигурных скобках через запятую определяется последовательность элементов, где для каждого элемента сначала указывается ключ и через двоеточие его значение.</p>
<p>Определим словарь:</p>
<pre>
	users = {1: "Tom", 2: "Bob", 3: "Bill"}
</pre>
<p>В словаре users в качестве ключей используются числа, а в качестве значений - строки. То есть элемент с ключом 1 имеет значение "Tom", элемент с ключом 2 - 
значение "Bob" и т.д.</p>
<p>Другой пример:</p>
<pre>
	emails = {"tom@gmail.com": "Tom", "bob@gmai.com": "Bob", "sam@gmail.com": "Sam"}
</pre>
<p>В словаре emails в качестве ключей используются строки - электронные адреса пользователей и в качестве значений тоже строки - имена пользователей.</p>
<p>Но необязательно ключи и строки должны быть однотипными. Они могу представлять разные типы:</p>
<pre>	objects = {1: "Tom", "2": True, 3: 100.6}</pre>
<p>Мы можем также вообще определить пустой словарь без элементов:</p>
<pre>	objects = {}</pre>
<p>или так:</p>
<pre >
	objects = dict()
</pre>	

<h2 id="a1">Создание словаря на основании списков и кортежей&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением.
Приведенный ниже код:</p>	
	<pre>
	<code>
	info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей
	info_dict = dict(info_list)  # создаем словарь на основе списка кортежей
	</code>
	</pre>
	<p>создает словарь с тремя элементами, где ключи — строки name, age, job, а соответствующие им значения — 'Timur', 28, 'Teacher'.
Аналогично работает приведенный ниже код:</p>
	<pre><code>
	info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков
	info_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков
		<p>Подобное можно сделать и из двухмерного списка со списками и двухмерного кортежа с кортежами</p>
<pre>
	users_list = [["55", "Tom"], ["57", "Bob"], ["67", "Alice"]]
	users_dict = dict(users_list)
	print(users_dict)

	выведет
	{'55': 'Tom', '57': 'Bob', '67': 'Alice'}
</pre>
<pre>
	users_tuple = (("55", "Tom"), ("57", "Bob"), ("67", "Alice"))
	users_dict = dict(users_tuple)
	print(users_dict)

	выведет
	{'55': 'Tom', '57': 'Bob', '67': 'Alice'}
</pre>
	</code></pre>
<h2 id ="a3">Создание словаря с значниями по умолчанию при помощи функции fromkeys()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
	<p>Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом fromkeys().
Приведенный ниже код:</p>
<pre><code>
	dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')
</code></pre>
<p>создает словарь с тремя элементами, где ключи — строки 'name', 'age', 'job', а соответствующие им значения: 'Missed information', 'Missed information', 'Missed information'
Если методу fromkeys() не передать второй параметр, то по умолчанию присваивается значение None.
Приведенный ниже код:</p>
<pre>
	dict1 = dict.fromkeys(['name', 'age', 'job'])
	print(dict1)
</pre>
	<p>создает словарь с тремя элементами</p>

	<p>{'name': None, 'age': None, 'job': None}</p>


<h2 id="a2">Создание словаря при помощи функции zip()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Создать словарь на основании двух списков (кортежей) можно с помощью встроенной функции-упаковщика <b>zip()</b>
Приведенный ниже код:</p>
<pre>
	keys = ['name', 'age', 'job']
	values = ['Timur', 28, 'Teacher']
	info = dict(zip(keys, values))
	print(info)

выводит (порядок элементов может отличаться):

	{'name': 'Timur', 'age': 28, 'job': 'Teacher'}

В случае несовпадения длины списков, функция самостоятельно отсечет лишние элементы.
	keys = ['name', 'age']
	values = ['Timur', 28, 'Teacher']
	info = dict(zip(keys, values))
	print(info)

	{'name': 'Timur', 'age': 28}
</pre>


<h2 id="a7">Встроенные функции sum(), min(), max()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre>
Встроенная функция <b>sum()</b> принимает в качестве аргумента словарь с числовыми ключами и вычисляет сумму его ключей.
Следующий программный код:

	my_dict = {10: 'Россия', 20: 'США', 30: 'Франция'}
	print('Сумма всех ключей словаря =', sum(my_dict))

выводит:

	Сумма всех ключей словаря = 60
	Для корректной работы функции sum() ключами словаря должны быть именно числа.

Встроенные функции <b>min()</b> и <b>max()</b> принимают в качестве аргумента словарь и находят минимальный и максимальный ключ соответственно, при этом ключ может принадлежать к любому типу данных, для которого возможны операции порядка <, <=, >, >= (числа, строки, и т.д.). 

Следующий программный код:

	capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
	months = {1: 'Январь', 2: 'Февраль', 3: 'Март'}
	print('Минимальный ключ =', min(capitals))
	print('Максимальный ключ =', max(months))

выводит:

	Минимальный ключ = Россия
	Максимальный ключ = 3
</pre>

<h2 id="a4">Сравнение словарей&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre>
Словари можно сравнивать между собой. Равные словари имеют одинаковое количество элементов и содержат равные элементы (ключ: значение).
Для сравнения словарей используются операторы == и !=.

Приведенный ниже код:

	months1 = {1: 'Январь', 2: 'Февраль'}
	months2 = {1: 'Январь', 2: 'Февраль', 3: 'Март'}
	months3 = {3: 'Март', 1: 'Январь', 2: 'Февраль'}
	print(months1 == months2)
	print(months2 == months3)
	print(months1 != months3)

выводит:

	False
	True
	True
</pre>

<h2 id="a6">Получение и изменение элементов&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для обращения к элементам словаря после его названия в квадратных скобках указывается ключ элемента:</p>
<pre>dictionary[ключ]</pre>
<p>Например, получим и изменим элементы в словаре:</p>
<pre>
	users = {"11": "Tom", "33": "Bob", "+55": "Alice"}

# получаем элемент с ключом "11"

	print(users["11"])

	Tom

# установка значения элемента с ключом "33"
	users["33"] = "Bob Smith"
	print(users["33"])

	Bob Smith
</pre>
<p>Если при установки значения элемента с таким ключом в словаре не окажется, то произойдет его добавление:</p>
<pre>
	users["44"] = "Sam"
</pre>
<p>Но если мы попробуем получить значение с ключом, которого нет в словаре, то Python сгенерирует ошибку KeyError:</p>
<pre>
	user = users["44"]	# KeyError
</pre>

<p>И чтобы предупредить эту ситуацию перед обращением к элементу мы можем проверять наличие ключа в словаре с помощью выражения <span class="b">ключ in словарь</span>. Если ключ имеется в словаре, 
то данное выражение возвращает True:</p>
<pre>
	key = "44"
	if key in users:
		user = users[key]
		print(user)
	else:
		print("Элемент не найден")

	Проверка наличия значения в словаре:

	capitals = {'Россия': 'Москва', 'Франция': 'Париж', 'Чехия': 'Прага'}
	if 'Париж' in capitals.values():
		print('В словаре есть значение Париж')

	В словаре есть значение Париж


</pre>
<h2 id="a5">Получение элементов при помощи get()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Также для получения элементов можно использовать метод <b>get</b>, который имеет две формы:</p>
<ul>
<li><p><code>get(key)</code>: возвращает из словаря элемент с ключом <b>key</b>. Если элемента с таким ключом нет, то возвращает значение <b>None</b></p></li>
<li><p><code>get(key, default)</code>: возвращает из словаря элемент с ключом <b>key</b>. Если элемента с таким ключом нет, то возвращает значение
по умолчанию default</p></li>
</ul>
<pre>
	users = {"1": "Tom", "3": "Bob", "5": "Alice"}
	user1 = users.get("5")
	user2 = users.get("3", "Unknown user")
	user3 = users.get("4", "Unknown user")
	print(user1)
	print(user2)
	print(user3)

	выведет
	Alice
	Bob
	Unknown user

	По методу <b>get()</b> необходимо помнить:

	d = {'b': 77, 'c': 88}
	print(d.get('a', 66))
	print(d)

В итоге получаем:

	66
	{'b': 77, 'c': 88}

т.е. get() выводит указанное вторым аргументом значение (если не указано, то по умолчанию None), но при этом <b>НЕ изменяет сам словарь</b>, что существенно!

Чтобы изменить словарь (добавить пару "а" = 66) надо не забывать делать присвоение, т.е. d['a'] = d.get('a', 66). Это же самое относится и к изменениям значения. Это дополнительное отличие от setdefault()
Вот это d['a'] = d.get('a', 66) и вот это -  d['a'] = 66 совсем не одно и то же! Во втором случае мы добавляем  значение для данного ключа "а" непосредственно, а в первом - по умолчанию. Само присвоение такого рода d['a'] = d.get('a', 66) использовать не рационально, однако же конструкции с ним используются, например, для счетчика с заданием начального значения (в данном случае 66). Обычно такой счетчик прописывают так: d['a'] = d.get('a', 0) +1, т.е. начальное значение 0 и при каждом новом вызове этой конструкции значение по ключу увеличивается на один

При помощи оператора get() можно организовать своеобразный поиск по словарю:

	info = {'names': 'Bob',
        'age': 25,
        'job': 'Dev'}
	print(info.get('name', info.get('job')))

выведет:
	Dev

	При обращение к ключу 'name'(его нет в словаре) произойдет переобращение к значению по умолчанию, а именно
info.get('job') и вывод значения Dev


</pre>
<h2 id="a8">Удаление del&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для удаления элемента по ключу применяется оператор <b>del</b>:</p>
<pre>
	users = {"+11": "Tom",  "+33": "Bob", "+55": "Alice"}

	del users["+55"]
	print(users)
	{ "+11": "Tom", "+33": "Bob"}
</pre>
<p>Но стоит учитывать, что если подобного ключа не окажется в словаре, то будет выброшено исключение KeyError. Поэтому опять же перед удалением желательно 
проверять наличие элемента с данным ключом.</p>
<pre>
	users = {"+11111111": "Tom", "+33333333": "Bob", "+55555555": "Alice"}

	key = "+55555555"
	if key in users:
		del users[key]
		print(f"Элемент с ключом {key} удален")
	else:
		print("Элемент не найден")
</pre>
<h2 id="a9">Удаление элементов pop()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Другой способ удаления представляет метод <b>pop()</b>. Он имеет две формы:</p>
<ul>
<li><p><code>pop(key)</code>: удаляет элемент по ключу key и возвращает удаленный элемент. Если элемент с данным ключом отсутствует, то генерируется 
исключение KeyError</p></li>
<li><p><code>pop(key, default)</code>: удаляет элемент по ключу key и возвращает удаленный элемент. Если элемент с данным ключом отсутствует, 
то возвращается значение default</p></li>
</ul>
<pre>
	users = {"1": "Tom", "3": "Bob", "5": "Alice"}
	key = "5"
	user = users.pop(key)
	print(user)

выдаст

	Alice

	user = users.pop("+4444444", "Unknown user")
	print(user)

выдаст

	Unknown user


</pre>
<h2 id="a91">Удаление методом popitem()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
	<pre>
		Метод <b>popitem()</b> удаляет из словаря последний добавленный элемент и возвращает удаляемый элемент в виде кортежа (ключ, значение).

Следующий программный код:

	info = {'name': 'Bob',
		 'age': 25,
		 'job': 'Dev'}

	info['surname'] = 'Sinclar'
	item = info.popitem()
	print(item)
	print(info)

выводит:

	('surname', 'Sinclar')
	{'name': 'Bob', 'age': 25, 'job': 'Dev'}
	</pre>
<h2 id="a10">Удаление всех элементов&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Если необходимо удалить все элементы, то в этом случае можно воспользоваться методом <b>clear()</b>:</p>
<pre>	users.clear()</pre>

<h2 id="a11">Копирование словарей&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Метод <b>copy()</b> копирует содержимое словаря, возвращая новый словарь:</p>
<pre>
	users = {"111": "Tom", "333": "Bob", "555": "Alice"}
	students = users.copy()
	print(students)

	{"111": "Tom", "333": "Bob", "555": "Alice"}

	Если бы значением по ключу 111 была бы не строка, а список то изменение одного из значений ключа 111 в users отразилось бы
и в students:

	users = {"111": ["Tom", "Piter"], "333": "Bob", "555": "Alice"}
	students = users.copy()
	users['111'][0] = 9
	print(users)
	print(students)

выведет:
	{'111': [9, 'Piter'], '333': 'Bob', '555': 'Alice'}
	{'111': [9, 'Piter'], '333': 'Bob', '555': 'Alice'}

	Решением проблемы является функция deepcopy() модуля copy:

	import copy
	users = {"111": ["Tom", "Piter"], "333": "Bob", "555": "Alice"}
	students = copy.deepcopy(users)
	users['111'][0] = 9
	print(users)
	print(students)

выведет:
	{'111': [9, 'Piter'], '333': 'Bob', '555': 'Alice'}
	{'111': ['Tom', 'Piter'], '333': 'Bob', '555': 'Alice'}
</pre>
<h2 id="a12">Объединение словарей&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Метод <b>update()</b> объединяет два словаря, добовляя в первый значения второго:</p>
<pre>
	users = {"1": "Tom", "3": "Bob"}
	users2 = {"2": "Sam", "6": "Kate"}
	users.update(users2)
	print(users)
	print(users2)

	{'1': 'Tom', '3': 'Bob', '2': 'Sam', '6': 'Kate'}
	{'2': 'Sam', '6': 'Kate'}
</pre>
<p>При этом словарь users2 остается без изменений. Изменяется только словарь users, в который добавляются элементы другого словаря. 
Но если необходимо, чтобы оба исходных словаря были без изменений, а результатом объединения был какой-то третий словарь, то можно предварительно 
скопировать один словарь в другой:</p>
<pre>
	users3 = users.copy()
	users3.update(users2)

	В Python 3.9 появились операторы | и |= которые реализуют операцию конкатенации словарей.

Приведенный ниже код:

	info1 = {'name': 'Bob', 'age': 25, 'job': 'Dev'}
	info2 = {'age': 30,	'city': 'New York', 'email': 'bob@web.com'}
	info1 |= info2
	info3 = info1 | info2
	print(info1)
	print(info3)

{'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}
{'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}

Объединить два словаря в третий также можно используя следующий код:

	info1 = {'name': 'Bob', 'age': 25, 'job': 'Dev'}
	info2 = {'age': 30,	'city': 'New York', 'email': 'bob@web.com'}
	info3 = {**info1, **info2}
	print(info3)

{'name': 'Bob', 'age': 30, 'job': 'Dev', 'city': 'New York', 'email': 'bob@web.com'}



</pre>
<h2 id="a13">Перебор словаря&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для перебора словаря можно воспользоваться циклом for:</p>
<pre>
	users = {"+11111111": "Tom", "+33333333": "Bob", "+55555555": "Alice"}
	for key in users:
		print(f"Phone: {key}  User: {users[key]} ")

	Phone: +11111111  User: Tom
	Phone: +33333333  User: Bob
	Phone: +55555555  User: Alice

</pre>
<p>При переборе элементов мы получаем ключ текущего элемента и по нему можем получить сам элемент.</p>
<p>Другой способ перебора элементов представляет использование метода <b>items()</b>:</p>
<pre>
	users = { "+11111111": "Tom", "+33333333": "Bob", "+55555555": "Alice"}
	for key, value in users.items():
		print(f"Phone: {key}  User: {value} ")

	Phone: +11111111  User: Tom
	Phone: +33333333  User: Bob
	Phone: +55555555  User: Alice
</pre>
<p>Метод <code>items()</code> возвращает набор кортежей. Каждый кортеж содержит ключ и значение элемента, которые при переборе мы тут же можем получить 
в переменные key и value.</p>
<p>Также существуют отдельно возможности перебора ключей и перебора значений. Для перебора ключей мы можем вызвать у словаря метод <b>keys()</b>:</p>
<pre>
	for key in users.keys():
		print(key)

	+11111111
	+33333333
	+55555555
</pre>
<p>Правда, этот способ перебора не имеет смысла, так как и без вызова метода keys() мы можем перебрать ключи, как было показано выше.</p>
<p>Для перебора только значений мы можем вызвать у словаря метод <b>values()</b>:</p>
<pre>
	for value in users.values():
		print(value)

	Tom
	Bob
	Alice

Словарные методы items(), keys(), values() возвращают не совсем обычные списки. Типы этих списков -  dict_items, dict_keys, dict_values соответственно,
в отличие от обычных списков - list. Методы обычных списков недоступны для списков типа dict_items, dict_keys, dict_values.
Используйте явное преобразование с помощью функции list() для получения доступа к методам списков.



</pre>
<h2 id="a14">Сортировка словаря&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre>
	Так как словарь состоит из пар, то и отсортировать его можно как по ключам, так и по значениям.
Сортировка по ключам выполняется с использованием функции sorted().
Приведенный ниже код:

capitals = {'Россия': 'Москва', 'Англия': 'Лондон', 'Чехия': 'Прага', 'Бразилия':'Бразилиа'}

	for key in sorted(capitals):
		print(key)
будет гарантированно выводить ключи словаря в алфавитном порядке, по возрастанию:

	Англия
	Бразилия
	Россия
	Чехия

	Обратите внимание: функция sorted() возвращает отсортированный список ключей, а не словарь. Не путайте встроенную функцию sorted()
и списочный метод sort(). Словари не содержат метода sort().
Для сортировки словаря по значениям можно использовать функцию sorted() вместе с методом items().
Приведенный ниже код:

	capitals = {'Россия': 'Москва', 'Англия': 'Лондон', 'Чехия': 'Прага', 'Бразилия':'Бразилиа'}
	for key, value in sorted(capitals.items(), key = lambda x: x[1]):
		print(value)

будет гарантированно выводить значения словаря в алфавитном порядке, по возрастанию:

	Бразилиа
	Лондон
	Москва
	Прага

	Стоит учитывать, что sorted(capitals.items(), key= lambda x: x[1]) возвращает не словарь, а отсортированный по значению список кортежей.
При сортировке словаря по значениям, мы используем анонимную функцию lambda x: x[1].
	Иногода бывает, что надо отсортировать словарь по убыванию значений, а если значения одинаковые, то по возрастанию ключей...

	my_dict = {'foo': 400, 'baz': 200, 'zar': 200, 'aab': 200, 'aaa': 100}
	sorted(sorted(my_dict.items(), key=lambda x: x[0]), key=lambda x: x[1], reverse=True)

или
	my_dict = {'foo': 400, 'baz': 200, 'zar': 200, 'aab': 200, 'aaa': 100}
	sorted(my_dict.items(), key=lambda x:(-x[1], x[0]))

 (но это только для числовых значений ключа)
на выходе получаем отсортированный список кортежей


	[('foo', 400), ('aab', 200), ('baz', 200), ('zar', 200), ('aaa', 100)]

</pre>
<h2 id="a15">Комплексные словари&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Кроме простейших объектов типа чисел и строк словари также могут хранить и более сложные объекты - те же списки, кортежи или другие словари:</p>
<pre>
users = {
    "Tom": {
        "phone": "+971478745",
        "email": "tom12@gmail.com"
    },
    "Bob": {
        "phone": "+876390444",
        "email": "bob@gmail.com",
        "skype": "bob123"
    }
}
</pre>
<p>В данном случае значение каждого элемента словаря в свою очередь представляет отдельный словарь.</p>
<p>Для обращения к элементам вложенного словаря соответственно необходимо использовать два ключа:</p>
<pre>
	old_email = users["Tom"]["email"]
	users["Tom"]["email"] = "supertom@gmail.com"
	print(users["Tom"])

	{ phone": "+971478745", "email": "supertom@gmail.com }
</pre>
<p>Но если мы попробуем получить значение по ключу, который отсутствует в словаре, Python сгенерирует исключение KeyError:</p>
<pre>
	tom_skype = users["Tom"]["skype"]

	KeyError
</pre>
<p>Чтобы избежать ошибки, можно проверять наличие ключа в словаре:</p>
<pre>
	key = "skype"
	if key in users["Tom"]:
		print(users["Tom"]["skype"])
	else:
		print("skype is not found")
</pre>
<p>Во всем остальном работа с комплексными и вложенными словарями аналогична работе с обычными словарями.</p>

<h2 id="a16">Метод setdefault()&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
	<pre>
		Метод <b>setdefault()</b> позволяет получить значение из словаря по заданному ключу, автоматически добавляя элемент словаря, если он отсутствует.
Метод принимает два аргумента:

	dict.setdefault(key[,default])

 	key: 		ключ, значение по которому следует получить, если таковое имеется в словаре, либо создать.
 	default:    значение, которое будет использовано при добавлении нового элемента в словарь.

В зависимости от значений параметров key и default возможны следующие сценарии работы данного метода.
Сценарий 1. Если ключ key присутствует в словаре, то метод возвращает значение по заданному ключу (независимо от того, передан параметр default или нет).
Приведенный ниже код:

	info = {'name': 'Bob',  'age': 25}
	name1 = info.setdefault('name')           # параметр default не задан
	name2 = info.setdefault('name', 'Max')    # параметр default задан
	print(name1)
	print(name2)

выводит:

	Bob
	Bob
Сценарий 2. Если ключ key отсутствует в словаре, то метод вставляет переданное значение default по заданному ключу.
Приведенный ниже код:

	info = {'name': 'Bob', 'age': 25}
	job = info.setdefault('job', 'Dev')
	print(info)
	print(job)

выводит:

	{'name': 'Bob', 'age': 25, 'job': 'Dev'}
	Dev

При этом если значение default не передано в метод, то вставится значение None.
Приведенный ниже код:

	info = {'name': 'Bob', 'age': 25}
	job = info.setdefault('job')
	print(info)
	print(job)

выводит:

	{'name': 'Bob', 'age': 25, 'job': None}
	None

<h2 id="a18">Генератор словарей&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre>
Общий вид генератора словаря следующий:

	<b>{ключ: значение for переменная in последовательность}</b>

где переменная — имя некоторой переменной,
	последовательность — последовательность значений, которые она принимает (любой итерируемый объект),
	ключ: значение — некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной,
		которой будут заполнены элементы словаря.
Пример изменения пары ключ - значение местами:

	s = {0: 'A', 1: 'B', 2: 'C', 3: 'D'}
	s1 = {v: k for k, v in s.items()}
	print(s1)

	{'A': 0, 'B': 1, 'C': 2, 'D': 3}

	Условия в генераторе словарей
В генераторах словарей можно использовать условный оператор.

	{(some_key1 if condition else some_key2):(something1  if condition else something2) for key, value in dict_.items()}
	или
	{some_key:something for key, value in dict_.items() if condition1 if condition2...if conditionN}

Пример нахождения пары из словаря с делителями 2 и 3, и еще число должно быть больше 2:

	dict1 = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f':6}
	dict1_tripleCond = {k:v for (k,v) in dict1.items() if v>2 if v%2 == 0 if v%3 == 0}
	print(dict1_tripleCond)

	{'f': 6}


</pre>

	</pre>
<h2 id="a17">Примечание&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre>
Примечание 1. Обращение по индексу и срезы недоступны для словарей.

Примечание 2. Операция конкатенации + и умножения на число * недоступны для словарей.
Примечание 3. Словарь можно использовать вместо нескольких вложенных условий, если вам нужно проверить число на равенство. Например вместо

	num = int(input())
	if num == 1:
		description = 'One'
	elif num == 2:
		description = 'Two'
	elif num == 3:
		description = 'Three'
	else:
		description = 'Unknown'
	print(description)

можно написать

	num = int(input())
	description = {1: 'One', 2: 'Two', 3: 'Three'}
	print(description.get(num, 'Unknown'))

На практике, такой код встречается достаточно часто. Особенно если в программе необходимо часто осуществлять проверку указанного типа.



</pre>















 <a href="#a">Up</a></h2></span></span>

</body>
</html>	
