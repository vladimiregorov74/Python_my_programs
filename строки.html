<!DOCTYPE html>
<html  lang="ru">
<head>
<title >Cтроки</title>
<body>
<span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">
        <a href="file:///media/vladimir/Games+/Python_books/HTML/help/0_Помощь_Python.html">Помощь_Python.html</a></span></span>
  <hr>
	<span style="font-size:18px;"><span style="font-family:arial,helvetica,sans-serif;">

	<h2 id="a">Рассмотрим основные методы строк, которые мы можем применить в приложениях:</h2>

<ul>
<h2 style="text-align: center;"><strong>Таблица &#171;Функции и методы строк&#187;</strong></h2>

<table border="0">
<thead valign="bottom">
<tr>
<th class="head">Функция или метод</th>
<th class="head">Назначение</th>
</tr>
</thead>
<tbody valign="top">
<tr>
<td><b>S = 'str'; S = "str"; S = '''str'''; S = """str"""</b></td>
<td>Литералы строк</td>
</tr>
<>
<td><b><a href="#a12">S = "s\np\ta\nbbb"</b></a></td>
<td>Экранированные последовательности</td>
</tr>
<tr>
<td><b><a href="#a11">S = r"C:\temp\new"</b></a></td>
<td>Неформатированные строки (подавляют экранирование)</td>
</tr>
<tr>
<td><b><a href="#a13">S = b"byte"</b></a</td>
<td>Строка байтов</td>
</tr>
<tr>
<td><b><a href="#a2">S1 + S2</b></a></td>
<td>Конкатенация (сложение строк)</td>
</tr>
<tr>
<td><b>S1 * 3</b></td>
<td>Повторение строки</td>
</tr>
<tr>
<td><b>S[i]</b></td>
<td>Обращение по индексу</td>
</tr>
<tr>
<td><b><a href="#a2">S[i:j:step]</b></a></td>
<td>Извлечение среза</td>
</tr>
<tr>
<td><b><a href="#a5">len(S)</b></a></td>
<td>Длина строки</td>
</tr>
<tr>
<td><b><a href="#a3">S.find</b>(str, [start],[end])</a></td>
<td>Поиск подстроки в строке. Возвращает номер первого вхождения или -1</td>
</tr>
<tr>
<td><b><a href="#a3">S.rfind</b>(str, [start],[end])</a></td>
<td>Поиск подстроки в строке. Возвращает номер последнего вхождения c права или -1</td>
</tr>
<tr>
<td><b><a href="#a3">S.index</b>(str, [start],[end])</a></td>
<td>Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError</td>
</tr>
<tr>
<td><b><a href="#a3">S.rindex</b>(str, [start],[end])</a></td>
<td>Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError</td>
</tr>
<tr>
<td><b><a href="#a4">S.replace</b>(шаблон, замена [, макс. кол-во замен])</a></td>
<td>Замена шаблона</td>
</tr>
<tr>
<td><b><a href="#a2">S.split</b>(символ)</a></td>
<td>Разбиение строки по разделителю</td>
</tr>
<tr>
<td><b><a href="#a8">S.isdigit</b>()</a></td>
<td>Состоит ли строка из цифр</td>
</tr>
<tr>
<td><b><a href="#a8">S.isalpha</b>()</a></td>
<td>Состоит ли строка из букв</td>
</tr>
<tr>
<td><b><a href="#a8">S.isalnum</b>()</a></td>
<td>Состоит ли строка из цифр или букв</td>
</tr>
<tr>
<td><b><a href="#a8">S.islower</b>()</a></td>
<td>Состоит ли строка из символов в нижнем регистре</td>
</tr>
<tr>
<td><b><a href="#a8">S.isupper</b>()</a></td>
<td>Состоит ли строка из символов в верхнем регистре</td>
</tr>
<tr>
<td><b><a href="#a8">S.isspace</b>()</a></td>
<td>Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))</td>
</tr>
<tr>
<td><b><a href="#a8">S.istitle</b>()</a></td>
<td>Начинаются ли слова в строке с заглавной буквы</td>
</tr>
<tr>
<td><b><a href="#a8">S.isascii() </b>()</a></td>
<td>Содержит лишь символы из кодировки ASCII</td>
</tr>
<tr>
<td><b><a href="#a8">S.isdecimal()</b>()</a></td>
<td>Содержит только символы цифр (обычных, надстрочных и подстрочных)</td>
</tr>
<tr>
<td><b><a href="#a8">S.isnurneric()</b>()</a></td>
<td>Содержит только символы чисел (обычные и римские цифры, дробные числа)</td>
</tr>
<tr>
<td><b><a href="#a8">S.isprintable()</b>()</a></td>
<td>Содержит только печатаемые символы</td>
</tr>
<td><b><a href="#a8">S.isspace()</b>()</a></td>
<td>Содержит только пробельные символы</td>
</tr>
<td><b><a href="#a8">S.isidentifier()</b>()</a></td>
<td>Содержит допустимые с точки зрения Python имена переменных, функций или классов</td>
</tr>
<tr>
<td><b><a href="#a6">S.upper</b>()</a></td>
<td>Преобразование строки к верхнему регистру</td>
</tr>
<tr>
<td><b><a href="#a6">S.lower</b>()</a></td>
<td>Преобразование строки к нижнему регистру</td>
</tr>
<tr>
<td><b><a href="#a3">S.startswith</b>(str)</a></td>
<td>Начинается ли строка S с шаблона str</td>
</tr>
<tr>
<td><b><a href="#a3">S.endswith</b>(str)</a></td>
<td>Заканчивается ли строка S шаблоном str</td>
</tr>
<tr>
<td><b><a href="#a2">S.join</b>(список)</a></td>
<td>Сборка строки из списка с разделителем S</td>
</tr>
<tr>
<td><b><a href="#a7">ord</b>(символ)</a></td>
<td>Символ в его код ASCII</td>
</tr>
<tr>
<td><b><a href="#a7">chr</b>(число)</a></td>
<td>Код ASCII в символ</td>
</tr>
<tr>
<td><b><a href="#a6">S.capitalize</b>()</a></td>
<td>Переводит первый символ строки в верхний регистр, а все остальные в нижний</td>
</tr>
<tr>
<td><b><a href="#a9">S.center</b>(width, [fill])</a></td>
<td>Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)</td>
</tr>
<tr>
<td><b><a href="#a3">S.count</b>(str, [start],[end])</a></td>
<td>Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец] (0 и длина строки по умолчанию)</td>
</tr>
<tr>
<td><b><a href="#a9">S.expandtabs</b>([tabsize])</a></td>
<td>Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам</td>
</tr>
<tr>
<td><b><a href="#a10">S.lstrip</b>([chars])</a></td>
<td>Удаление пробельных символов в начале строки</td>
</tr>
<tr>
<td><b><a href="#a10">S.rstrip</b>([chars])</a></td>
<td>Удаление пробельных символов в конце строки</td>
</tr>
<tr>
<td><b><a href="#a10">S.strip</b>([chars])</a></td>
<td>Удаление пробельных символов в начале и в конце строки</td>
</tr>
<tr>
<td><b><a href="#a10">S.striplines([False])</b>([chars])</a></td>
<td>разделяет текущую строку на подстроки по символу переводастроки (\n) и добавляет их в список.</td>
</tr>
<tr>
<td><b><a href="#a10">S.partition</b>(шаблон)</a></td>
<td>Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки</td>
</tr>
<tr>
<td><b><a href="#a10">S.rpartition</b>(sep)</a></td>
<td>Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем саму строку</td>
</tr>
<tr>
<td><b><a href="#a6">S.swapcase</b>()</a></td>
<td>Переводит символы нижнего регистра в верхний, а верхнего – в нижний</td>
</tr>
<tr>
<td><b><a href="#a6">S.title</b>()</a></td>
<td>Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний</td>
</tr>
<tr>
<td><b><a href="#a1">S.zfill</b>(width)</a></td>
<td>Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями</td>
</tr>
<tr>
<td><b><a href="#a9">S.ljust</b>(width, fillchar=" ")</a></td>
<td>Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar</td>
</tr>
<tr>
<td><b><a href="#a9">S.rjust</b>(width, fillchar=" ")</a></td>
<td>Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar</td>
</tr>
<tr>
<td><b><a href="#a1">S.format</a></b>(*args, **kwargs)</a></td>
<td>Форматирование строки</td>
</tr>
</tbody>
</table>

<h2 id="a2">Склеивание и разделение строк &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Самый простой способ склеить строки в Python &ndash; это сложить их с помощью знака&nbsp;&laquo;<strong>+</strong>&raquo;. Рассмотрим на примере:</p>
<pre>
	str = &quot;a&quot;+&quot;b&quot;
	print(str) # Выведет &quot;ab&quot;</pre>
<p>Но такой способ не всегда будет нам подходить. Рассмотрим метод <strong>join()</strong>:</p>
<pre>
	str = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
	print(&quot;&quot;.join(str)) # Выведет &quot;abc&quot;
</pre>
<p>Перед <strong>.join()</strong> мы указываем разделитель&nbsp;строк, а в скобках сам их массив.</p>
<p>Для того чтобы разделить строки, используем обратный метод &ndash; <strong>split()</strong>. Тут в скобках указываем набор символов, по которым будет идти разделение, а перед методом не забываем указать имя строки, а после нее поставить точку. Рассмотрим на примере:</p>
<pre>
	str = &quot;a,b,c&quot;
	print(str.split(&quot;,&quot;)) # Выведет [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</pre>
<p>Существует и другой способ&nbsp;разделения строк, он называется срез. Срез <strong>str[x:y]</strong> позволит нам получить строку от символа <strong>x</strong> до <strong>y</strong>.&nbsp;При этом необязательно указывать оба параметра, ведь в таком случае срез произойдет от начала или до самого конца строки.&nbsp;</p>
<p>Определенный промежуток:</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str[9:15]) # Выведет &quot;Python&quot;
</pre>
<p>С начала строки:</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str[:15]) # Выведет &quot;Строки в Python&quot;
</pre>
<p>До самого конца:</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str[18:]) # Выведет &quot;методы работы с ними&quot;
</pre>
<p>Также можно срезать каждый энный символ при помощи двойного двоеточия:</p>
<pre>
	str = &quot;123456789&quot;
	print(str[::2]) # Выведет &quot;13579&quot;</pre>
<h2 id="a1">Mетод <span class="b">format()</span> &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Mетод позволяет форматировать строку, вставляя в нее на место плейсхолдеров определенные значения.</p>
<p>Для вставки в строку используются специальные параметры, которые обрамляются фигурными скобками ({}).  
<h3>Именованные параметры</h3>
<p>В форматируемой строке мы можем определять параметры, в методе <code>format()</code> передавать для этих параметров значения:</p>
<pre class="brush:py;">
	text = "Hello, {first_name}.".format(first_name="Tom")
	print(text)     # Hello, Tom.
	info = "Name: {name}\t Age: {age}".format(name="Bob", age=23)
	print(info)     # Name: Bob	 Age: 23
</pre>
<p>Причем в метод формат аргументы определяются с тем же именем, что и параметры в строке. Так, если параметр называется <code>first_name</code>, как в первом случае, 
то аргумент, которому присваивается значение, также называется <code>first_name</code>.</p>

<h3>Параметры по позиции</h3>
<p>Мы также можем последовательно передавать в метод format набор аргументов, а в самой форматируемой строке вставлять эти аргумента, указывая в фигурных скобках их номер (нумерация начинается с нуля):</p>
<pre class="brush:py;">
	info = "Name: {0}\t Age: {1}".format("Bob", 23)
	print(info)     # Name: Bob	 Age: 23
</pre>
<p>При этом аргументы можно вставлять в строку множество раз:</p>
<pre class="brush:py;">text = "Hello, {0} {0} {0}.".format("Tom")</pre>
<h3>Подстановки</h3>
<p>Еще один способ передачи форматируемых значений в строку представляет использование подстановок или специальных плейсхолдеров, 
на место которых вставляются определенные значения. Для форматирования мы можем использовать следующие плейсхолдеры:</p>
<ul>
<li><p><span class="b">s</span>: для вставки строк</p></li>
<li><p><span class="b">d</span>: для вставки целых чисел</p></li>
<li><p><span class="b">f</span>: для вставки дробных чисел. Для этого типа также можно определить через точку количество знаков в дробной части.</p></li>
<li><p><span class="b">%</span>: умножает значение на 100 и добавляет знак процента</p></li>
<li><p><span class="b">e</span>: выводит число в экспоненциальной записи</p></li>
</ul>
<p>Общий синтаксис плейсхолдера следующий:</p>
<pre class="brush:py;">	{:плейсхолдер}</pre>
<p>В зависимости от плейсхолдера можно добавлять дополнительные параметры. Например, для форматирования чисел float можно использовать следующие параметры</p>
<pre class="brush:py;">
	<b>{:[количество_символов][запятая][.число_знаков_в_дробной_части] плейсхолдер}</b>
</pre>
<p>При вызове метода format в него в качестве аргументов передаются значения, которые вставляются на место плейсхолдеров:</p>
<pre class="brush:py;">
	welcome = "Hello {:s}"
	name = "Tom"
	formatted_welcome = welcome.format(name)
	print(formatted_welcome)		# Hello Tom
</pre>
<p>В качестве результата метод <code>format()</code> возвращает новую отформатированную строку.</p>
<p>Форматирование целых чисел:</p>
<pre class="brush:py;">
	source = "{:d} символов"
	number = 5
	target = source.format(number)
	print(target)   # 5 символов
</pre>
<p>Если форматируемое число больше 999, то мы можем указать в определении плейсхолдера, что мы хотим использовать запятую в качестве разделителя 
разрядов:</p>
<pre class="brush:py;">
	source = "{:,d} символов"
	print(source.format(5000))   # 5,000 символов
</pre>
<p>Причем плейсхолдеры можно использовать и в f-строках:</p>
<pre class="brush:py;">
	n = 5000
	source = f"{n:,d} символов"
	print(source)   # 5,000 символов
</pre>
<p>Для дробных чисел, то есть таких, которые представляют тип float, перед кодом плейсхолдера после точки можно указать, сколько знаков в дробной части 
мы хотим вывести:</p>
<pre class="brush:py;">
	number = 23.8589578
	print("{:.2f}".format(number))   # 23.86
	print("{:.3f}".format(number))   # 23.859
	print("{:.4f}".format(number))   # 23.8590
	print("{:,.2f}".format(10001.23554))    # 10,001.24
</pre>
<p>Еще один параметр позволяет установить минимальную ширину форматируемого значения в символах:</p>
<pre class="brush:py;">
	print("{:10.2f}".format(23.8589578))    #     23.86
	print("{:8d}".format(25))               #      25
</pre>
<p>Аналогичный пример с f-строками:</p>
<pre class="brush:py;">
	n1 = 23.8589578
	print(f"{n1:10.2f}")    #     23.86
	n2 = 25
	print(f"{n2:8d}")       #      25
</pre>
<p>Для вывода процентов лучше воспользоваться кодом "%":</p>
<pre class="brush:py;">
	number = .12345
	print("{:%}".format(number))        # 12.345000%
	print("{:.0%}".format(number))      # 12%
	print("{:.1%}".format(number))      # 12.3%

	print(f"{number:%}")        # 12.345000%
	print(f"{number:.0%}")      # 12%
	print(f"{number:.1%}")      # 12.3%
</pre>
<p>Для вывода числа в экспоненциальной записи применяется плейсхолдер "e":</p>
<pre class="brush:py;">
	number = 12345.6789
	print("{:e}".format(number))        # 1.234568e+04
	print("{:.0e}".format(number))      # 1e+04
	print("{:.1e}".format(number))      # 1.2e+04

	print(f"{number:e}")        # 1.234568e+04
	print(f"{number:.0e}")      # 1e+04
	print(f"{number:.1e}")      # 1.2e+04
</pre>

<h2 id="a12">Специальные символы &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<pre>Специaльные символы, как говорилось ранее, имеют особое значение и обрабатываются особым образом. Python поддерживает следующие специальные символы:
	♦ \n - перевод строки;
	♦ \r-возврат каретки;
	♦ \t-знак табуляции;
	♦ \v-вертикальная табуляция;
	♦ \а - звонок;
	♦ \b-забой;
	♦ \f-перевод формата;
	♦ \О-нулевой символ;
	♦ \" - двойная кавычка;
	♦ \' - одинарная кавычка (апостроф);
	♦ \\ - обратный слеш;
	♦ \<b>N</b> - символ с восьмеричным кодом <b>N</b>. Например, \74 соответствует символу <;
	♦ \x<b>N</b> - символ с шестнадцатеричным кодом <b>N</b>. Например, \х6а соответствует символу j;
	♦ \u<b>nnnn</b> - символ с 16-битным Unicode-кoдoм <b>nnnn</b>. Например, \u04За соответствует русской букве к;
	♦ \U<b>nnnnnnnn</b> - символ с 32-битным Unicode-кoдoм <b>nnnnnnnn</b>;
	♦ \N{<b>name</b>} - символ с Uniсоdе-именем <b>name</b>. Например, \N{Registered Sign} соответствует знаку зарегистрированной торговой марки ®·
	Комбинация обратного слеша с тобым другим символом выводится как есть:

	print("Этот символ \не специальный")
	Этот символ \не специальный

Тем не менее для вставки обратного слеша лучше использовать специальный символ \\:

	print("Этoт символ \\не специальный")
	Этот символ \не специальный
</pre>
<h2 id="a11">Необрабатываемые строки &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>В необрабатываемых строках специальные символы не обрабатываются, а выводятся как есть. Чтобы превратить строку в необрабатываемую, достаточно предварить ее модификатором r или R. Примеры:</p>
<pre>
	print("Cтpoкa1\nCтpoкa2")
	Строка1
	Строка2
	print(r"Cтpoкa1\nCтpoкa2"}
	Строка1\nСтрока2
	print(R"Cтpoкa1\nCтpoкa2")
	Строка1\nСтрока2
	print(r"'"'Строка1\nСтрока2""")
	Строка1\nСтрока2
</pre>
<p>Необрабатываемые строки удобно использовать в шаблонах регулярных выражений и при
записи файловых путей:</p>
<pre>
	print(r"C:\Python310\lib\site-packages")
	C:\Python310\lib\site-packages
</pre>
<p>В обычных строках все обратные слеши придется заменять на специальные символы \\:</p>
<pre>
	print("C:\\Python310\\lib\\site-packages")
	C:\Python310\lib\site-packages
</pre>
<p>Если в конце необрабатываемой строки должен располагаться слеш, следует использовать специальный символ \\. Однако этот символ будет добавлен в строку. Пример:</p>
<pre>
	print(r"C:\Python310\lib\site-packages\")
	SyntaxError: unterminated string literal (detected at line 1)
	print(r"C:\Python310\lib\site-packages\\")
	C:\Python310\lib\site-packages\\
</pre>
<p>Избавиться от лишнего слеша можно, использовав конкатенацию строк, обычные строки или удалив слеш явно:</p>
<pre>
	print(r"C:\Python310\lib\site-packages" + "\\") # Конкатенация
	C:\Python310\lib\site-packages\
	print("С:\\Python310\\lib\\site-packages\\")
	# Обычная строка
	C:\Python310\lib\site-packages\
	print(r"C:\PythonЗlO\lib\site-packages\\"(:-1]) # Удаление слеша
	C:\Python310\lib\site-packages\
</pre>

<h2 id="a9">Методы форматирования строк &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для форматирования строк также можно использовать следующие методы, поддерживаемые объектом строки:
<b>expandtabs([ <Ширина поля>])</b> - заменяет каждый символ табуляции в текущей строке пробелами так, чтобы общая ширина фрагмента вместе с текстом, расположенным перед символом табуляции, была равна указанной величине. Если параметр не указан, то
ширина поля предполагается равной 8 символам. Пример:</p>
<pre>
	s = "1\tl2\tl23\t"
	print("'%s'" % s.expandtabs(4))
	"'1    l2  123 '"
</pre>
<p>В этом примере ширина задана равной четырем символам. Поэтому во фрагменте 1\t табуляция будет заменена тремя пробелами, во фрагменте 12\t - двумя пробелами, а во фрагменте 123\t- одним пробелом. Во всех трех фрагментах ширина будет равна четырем символам.
Если перед символом табуляции нет текста или количество символов перед табуляцией равно указанной в вызове метода ширине, то табуляция заменяется указанным количеством пробелов:</p>
<pre>
	s = "\t"
	print("'%s' - '%s'" % (s.expandtabs(),s.expandtabs(4)))
	"'        ' - '    '"
	s = "1234\t"
	print("'%s'" % s.expandtabs(4))
	"'1234    '"
</pre>
<p>Если количество символов перед табуляцией больше ширины, то табуляция заменяется пробелами таким образом, чтобы ширина фрагмента вместе с текстом делилась без остатка на указанную ширину:</p>
<pre>
	s = "12345\t123456\t1234567\t1234567890\t"
	print("'%s'" % s.expandtabs(4))
	"'12345   123456  1234567 1234567890  '"
</pre>
<p>Таким образом, если количество символов перед табуляцией больше 4, но менее 8, то фрагмент дополняется пробелами до 8 символов. Если количество символов больше 8, но менее 12, то фрагмент дополняется пробелами до 12 символов и т. д. Все это справедливо при указании, в качестве параметра числа 4</p>
<p><b>center( <Ширина> [, <Символ>] )</b> - выравнивает текущую строку по центру внутри поля указанной ширины с добавлением слева и справа символов из второго параметра (если он не указан, будут добавлены пробелы):</p>
<pre>
	s = "str"
	print(s.center(15), s.center(11, "-"))
	'      str       ----str----'
</pre>
<p>Теперь произведем выравнивание трех фрагментов шириной 15 символов: первого -по правому краю, второго -по левому, а третьего -по центру:</p>
<pre>
	s = "str"
	print("'%15s' '%-15s' '%s'" % (s, s, s.center(15)))
	'            str' 'str            ' '      str      '
</pre>
<p>Если количество символов в текушей строке превышает ширину поля, то значение ширины игнорируется и строка возвращается полностью:</p>
<pre>
	s = "string"
	print(s.center(6), s.center(5))
	'string string'
</pre>
<p><b>ljust( <Ширина> [, <Символ>] )</b> - выравнивает текущую строку по левому краю внутри поля указанной ширины с добавлением справа символов из второго параметра ( если он не указан, будут добавлены пробелы). Если количество символов в текущей строке превышает ширину поля, то значение ширины игнорируется и строка возвращается полностью. Примеры:</p>
<pre>
	s = "string"
	print(s.ljust(15), s.ljust(15, "-"))
	'string          string---------' 
	print(s.ljust(6), s.ljust(5))
	'string string'
</pre>
<p><b>rjust( <Ширина> [, <Символ>] )</b> - выравнивает текущую строку по правому краю внутри поля указанной ширины с добавлением слева символов из второго параметра ( если он не указан, будут добавлены пробелы). Если количество символов в текущей строке превышает ширину поля, то значение ширины игнорируется и строка возвращается полностью. Пример:</p>
<pre>
	s = "string"
    print(s.rjust(15), s.rjust(15, "-"))
	'         string ---------string'
	print(s.rjust(б), s.rjust(5))
	'string string'
</pre>
<p><b>zfill(<Ширина>)</b> - выравнивает текущую строку по правому краю внутри поля указанной ширины с добавлением слева нулей. Если количество символов в текущей строке превышает ширину поля, то значение ширины шнорируется и строка возвращается пол­
ностью. Примеры:</p>
<pre>
	print("5".zfill(20), "123456".zfill(5))
	'00000000000000000005', '123456'
</pre>

<h2 id="a3">Поиск в строках &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Если нам нужно найти набор символов в начале или в конце данной строки, то на помощь&nbsp;приходят два быстрых метода.</p>
<p>Первый метод &ndash;&nbsp;<strong>startswith()</strong>. Он позволяет искать набор символов в начале строки. Рассмотрим на примере:</p>
<pre>
	str =  &quot;Строки в Python и методы работы с ними&quot;
	print(str.startswith(&quot;Строки&quot;)) #Выведет True</pre>
<p>Второй метод &ndash; <strong>endswith()</strong>. Он позволяет искать набор символов в конце строки. Рассмотрим на примере:</p>
<pre>
	str =  &quot;...я разбирал строки в JavaScript&quot;
	print(str.endswith(&quot;JavaScript&quot;)) #Выведет True</pre>
<p>А если нам нужно найти набор символов в произвольном месте строки, то используем метод <strong>find()</strong> или <strong>rfind()</strong> (поиск первого вхождения справа). Рассмотрим на примере:</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str.find(&quot;Python&quot;)) #Выведет 9</pre>
<p>В данном случае скрипт нашел набор символов в строке и вывел индекс начала его вхождения в ней.</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str.find(&quot;JavaScript&quot;)) #Выведет -1
</pre>
<p>А в этом случае скрипт не нашел набор символов в строке и вывел &laquo;<strong>-1</strong>&raquo;.</p>
<p>Методы <b>index()</b> и <b>rindex()</b> - аналогичны методам <b>find()</b> и <b>rfind()</b>, но если подстрока не найдена, возбуждает исключение ValueError</p>
<p>Метод <b>count()</b> - возвращает число вхождений заданной подстроки в текущую строку. Регистр символов учитывается. Формат метода:</p>
<p> <b>S.count(str, [start],[end])</b></p>
<p>Если параметр <b>[start]</b> не указан, то подсчет подстрок будет производиться во всей текущей строке. Если параметры <b>[start]</b> и <b>[end]</b> указаны, то извлекается срез строки и подсчет подстрок производится в полученном фрагменте. Примеры:</p>
<pre class="brush:py;">
	s = "пример пример Пример Пример"
	print(s.соuпt("при"), s.count("пpи", 6), s.count("Пpи"))
	(2, 1, 2)
	print(s. count ("тест"))
	0
</pre>

<h2 id="a4">Замена в строках &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для замены одного набора символов на другой в строке используют метод <strong>replace()</strong>. Рассмотрим данный метод на примере:</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str.replace(&quot;Python&quot;, &quot;JavaScript&quot;)) #Выведет &quot;JavaScript&quot;</pre>

<h2 id="a5">Узнаем длину строки &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для того чтобы получить длину строки, используем метод <strong>len()</strong>:</p>
<pre>
	str = &quot;123&quot;
	print(len(str)) # Выведет 3</pre>

<h2 id="a6">Изменение регистра строк в Python &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для того чтобы все буквы в строке были заглавными, используем метод <strong>upper()</strong>:</p>
<pre>
	str = &quot;Строки в Python и методы работы с ними&quot;
	print(str.upper()) # Выведет &quot;СТРОКИ В PYTHON И МЕТОДЫ РАБОТЫ С НИМИ&quot;
</pre>
<p>И метод <strong>lower()</strong> для строчных букв:</p>
<pre>
	str = &quot;СТРОКИ В PYTHON И МЕТОДЫ РАБОТЫ С НИМИ&quot;
	print(str.upper()) # Выведет &quot;строки в python и методы работы с ними&quot;
</pre>
<p>Чтобы первая буква в строке стала заглавной,&nbsp;следует использовать&nbsp;метод <strong>capitalize()</strong>:</p>
<pre>
	str = &quot;строки в python и методы работы с ними&quot;
	print(str.capitalize()) # Выведет &quot;Строки в python и методы работы с ними&quot;
</pre>
<p>Метод <b>swapcase()</b> - заменяет в текущей строке все строчные символы соответствующими прописными буквами, а все прописные символы - строчными: </p>
<pre class="brush:py;">
	print("CTPOКA cтpoкa".swapcase())
	строка СТРОКА
</pre>
<p>Метод <b>title()</b> -делает первую букву каждого слова в текущей строке прописной:</p>
<pre class="brush:py;">
	s = "первая буква каждого слова станет прописной"
	print(s.title())
	Первая Буква каждого Слова Станет Прописной
</pre>

<h2 id="a7">Функции для работы с символами &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для работы с отдельными символами предназначены следующие функции:</p>
<pre class="brush:py;">
<b>chr( <Код символа>)</b> -возвращает символ по указанному коду:
	p rint(chr(l77))
	±
<p></p>
<b>ord(<Символ>)</b> -возвращает код указанного символа:
	p rint(ord("±"))
	177
</pre>

<h2 id="a8">Проверка содержимого строки &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Для проверки содержимого строки предназначены следующие методы:
<b>isalnurn()</b> -возвращает <b>True</b>, если текущая строка содержит только буквы и (или) цифры, в противном случае - <b>False</b>. Если строка пустая, возвращается <b>False</b>. Примеры:</p>
<pre class="brush:py;">
	print("0123".isalnurn(), "123abc".isalnurn(), "abcl23".isalnurn())
	True, True, True
	print("строка".isalnurn())
	True
	print("".isalnurn(), "123 аЬс".isalnurn(), "аЬс, 123. ".isalnurn())
	False, False, False
</pre>
<p><b>isalpha()</b> -возвращает тrue, если текущая строка содержит только буквы, в противном случае -<b>False</b>. Если строка пустая, возвращается <b>False</b>. Примеры:</p>
<pre class="brush:py;">
	print("string".isalpha(), "строка".isalpha(), "".isalpha())
	True, True, False
	print("123abc".isalpha(), "str str".isalpha(), "st,st".isalpha())
	False, False, False
</pre>
<p><b>isascii()</b> (начиная с Python 3.7)- возвращает <b>True</b>, если текущая строка содержит лишь символы из кодировки ASCII, в противном случае - <b>False</b>. Если строка пустая, возвращается <b>True</b>. Примеры:</p>
<pre class="brush:py;">
	print("123abc".isascii(), "cтpoкa123".isascii(), "".isascii())
	True, False, True
</pre>
<p><b>isdigit()</b> - возвращает <b>True</b>, если текущая строка содержит только обычные цифры,в противном случае -<b>False</b>. Если строка пустая, возвращается <b>False</b>. Примеры:</p>
<pre class="brush:py;">
	print("0123".isdigit(), "123аЬс".isdigit(), "аЬс123".isdigit())
	True, False, False
</pre>
<p><b>isdecimal()</b> - возвращает <b>True</b>, если текущая строка содержит только символы цифр (обычных, надстрочных и подстрочных), в противном случае - <b>False</b>. Если строка пустая, возвращается <b>False</b>. Примеры:</p>
<pre class="brush:py;">
	print("123".isdecimal(), "123стр".isdecimal())
	True, False
</pre>
<p><b>isnurneric()</b> - возвращает <b>True</b>, если текущая строка содержит только символы чисел (обычные и римские цифры, дробные числа), в противном случае - <b>False</b>. Если строка пустая, возвращается <b>False</b>. Примеры:</p>
<pre>
	print("\u2155".isnurneric(), "\u2155".isdigit())
	True, False
	print("\u2155") # Выведет символ "1/5"
</pre>
<p><b>isupper()</b> - возвращает <b>True</b>, если текущая строка содержит буквы только, верхнего регистра, в противном случае - <b>False</b>. Если строка пустая или не содержит букв, возвращается <b>False</b>. Примеры:</p>
<pre>
	print("STRING".isupper(), "СТРОКА".isupper(), "".isupper())
	True, True, False
	print("STRINGl".isupper(), "СТРОКА, 123".isupper(), "123".isupper())
	True, True, False
	print("string".isupper(), "STRing".isupper())
	False, False
</pre>

<p><b>islower()</b> - возвращает <b>True</b>, если текущая строка содержит буквы только нижнего регистра, в противном случае - <b>False</b>. Если строка пустая или не содержит букв, возвращается <b>False</b>. Примеры:</p>
<pre>
	print("srting".islower(), "cтpoкa".islower(), "".islower())
	True, True, False
	print("stringl".islower(), "str, 123".islower(), "123".islower())
	True, True, False
	print("STRING".islower(), "Cтpoкa".islower())
	False, False
</pre>
<p><b>istitle()</b> - возвращает <b>True</b>, если все слова в текущей строке начинаются с заглавной буквы, в противном случае - <b>False</b>. Если строка пустая или не содержит букв, возвращается <b>False</b>. Примеры:</p>
<pre>
	print("Str Str".istitle(), "Стр Стр".istitle())
	True, True
	print("Str Str 123".istitle(), "Стр Стр 123".istitle())
	True, True
	print("Str str".istitle(), "Стр стр".istitle())
	False, False
	print("".istitle(), "123".istitle())
	False, False
</pre>
<p><b>isprintable()</b> - возвращает <b>True</b>, если текущая строка содержит только печатаемые символы, в противном случае - <b>False</b>. Пробел относится к печатаемым символам. Если строка пустая, возвращается тrue. Примеры:</p>
<pre>
	print("123".isprintable())
	True
	print("РНР Python".isprintable())
	True
	print("\n".isprintable())
	False
</pre>
<p><b>isspace()</b> - возвращает <b>True</b>, если текущая строка содержит только пробельные символы, в противном случае - <b>False</b>. Если строка пустая, возвращается <b>False</b>. Пример:</p>
<pre>
	print("".isspace(), " \n\r\t".isspace(), "str str".isspace())
	False, True, False
</pre>
<p><b>isidentifier()</b> - возвращает тrue, если текущая строка представляет собой допустимое с точки зрения Python имя переменной, функции или класса, в противном случае - <b>False</b>:</p>
<pre>
	print("s".isidentifier())
	True
	print("func".isidentifier())
	True
	print("123func".isidentifier())
	False
</pre>
<p>Следует иметь в виду, что метод <b>isidentifier()</b> лишь проверяет, удовлетворяет ли заданное имя правилам языка. Он не проверяет, совпадает ли это имя с каким-либо ключевым словом <b>Python</b>. Для выполнения такой проверки надлежит применять функцию <b>iskeyword()</b> из модуля <b>keyword</b>, которая возвращает <b>True</b>, если переданная ей строка совпадает с одним из ключевых слов, например:</p>
<pre>
	print(keyword.iskeyword ("else"))
	True
	print(keyword.iskeyword("elsewhere"))
	False
</pre>

<h2 id="a10">Основные методы, поддерживаемые строками &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p><b>strip([<Символы>])</b> - удаляет указанные в параметре символы в начале и в конце текущей строки. Если параметр не задан, удаляются пробельные символы: пробел, перевод строки <b>(\n)</b>, возврат каретки <b>(\r)</b>, горизонтальная <b>(\t)</b> и вертикальная <b>(\v)</b> табуляция.
Примеры:</p>
<pre>

	s1, s2 = "     str\n\r\v\t", "strstrstrokstrstrstr"
	print("'%s'-- '%s'" % (s1.strip(), s2.strip("tsr")))
	'str'-- 'ok'

	Если из строки j надо убрать все знаки припенания включая перевод каретки:
	l = j.strip('\n",.-:!?)

</pre>
<p><b>lstrip([<Символы>])</b>(<b>rstrip([<Символы>])</b>) - удаляет заданные(передние) символы в начале текущей строки (если параметр не указан, удаляет пробелы):</p>
<pre>
	s1, s2 = "     str      ", "strstrstrokstrstrstr      "
	print("'%s'-- '%s'" % (s1.lstrip(), s2.lstrip('tsr')))
	'str      '-- 'okstrstrstr      '
</pre>
<p><b>splitlines([False])</b> - разделяет текущую строку на подстроки по символу перевода строки <b>(\n)</b> и добавляет их в список. Символы новой строки вкточаются в результат, только если необязательный параметр имеет значение <b>True</b>. Если разделитель в текущей строке не найден, список будет содержать только один элемент - саму текущую строку. Примеры:</p>
<pre>
	print("wordl\nword2\nword3".splitlines())
	['wordl', 'word2', 'wordЗ' ]
	print("wordl\nword2\nword3".splitlines(True))
	['wordl\n', 'word2\n', 'wordЗ']
	print("wordl word2 wordЗ".splitlines())
	['wordl word2 wordЗ']
</pre>
<p>♦ <b>partition(<Разделитель>)</b> - находит первое вхождение указанного символа-разделителя в текущей строке и возвращает кортеж из трех элементов: фрагмента, расположенного перед разделителем, разделителя и фрагмента, расположенного после разделителя.
Поиск производится слева направо. Если символ-разделитель не найден, то первый элемент кортежа будет содержать текущую строку, а остальные элементы останутся пустыми. Примеры:</p>
<pre>
	print("word1 word2 wordЗ".partition(" "))
	('word1', ' ', 'word2 wordЗ')
	print("word1 word2 wordЗ".partition("\n"))
	('word1 word2 wordЗ', '', '')
</pre>
<p>♦ <b>rpartition(<Разделитель>)</b> - аналогичен методу partition(), но поиск символа разделителя производится не слева направо, а наоборот - справа налево. Если символ разделитель не найден, то первые два элемента кортежа окажутся пустыми, а третий элемент будет содержать текущую строку. Примеры:</p>

<pre>
	print("word1 word2 wordЗ".rpartition(" "))
	('word1 word2', ' ', 'wordЗ')
	print("word1 word2 wordЗ".rpartition("\n"))
	('', '', 'word1 word2 wordЗ')
</pre>

<h2 id="a13">Двоичные данные типа bytes &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="#a">Up</a></h2>
<p>Тип данных bytes представляет неизменяемую последовательность байтов (чисел от О ДО 255).
Создать значение типа bytes можно следующими способами:</p>
<p>♦ с помощью функции <b>bytes([<Строка>, <Кодировка> [, <Обработка Ошибок>]])</b>. Если параметры не указаны, то возвращается пустая последовательность байтов. Чтобы преобразовать заданную · строку в значение типа bytes, необходимо передать минимум два первых параметра. Если указан только первый параметр, то возбуждается искточение <b>TypeError</b>. Примеры:</p>
<pre>
	bytes()
	b''
	print(bytes("строка", "ср1251"))
	b'\xfl\xf2\xf0\xee\xea\xe0'
    print(bytes("строка"))
Traceback (most recent call last):
	File "<pyshell#ЗЗ>", line 1, in <module>
		bytes("строка")
TypeError: string argument without an encoding
</pre>
<p>В третьем параметре могут быть указаны значения <b>"strict"</b> (при ошибке возбуждается искточение <b>UnicodeEncodeError</b>- значение по умолчанию), <b>"replace"</b> (неизвестный символ заменяется знаком вопроса) или <b>"ignore"</b> (неизвестные символы игнорируются):</p>
<pre>
	print(bytes("string\uFFFD", "ср1251", "strict"))
	Traceback (most recent call last):
		File "<pyshell#ЗS>", line 1, in <module>
			bytes("string\uFFFD", "ср1251", "strict")
		File "C:\Python310\lib\encodings\cp1251.py", line 12, in encode
			return codecs.charmap_encode(input,errors,encoding_taЬle)
	UnicodeEncodeError: 'charmap' codec can't encode character
	'\ufffd' in position 6: character maps to <undefined>
	print(bytes("string\uFFFD", "ср1251", "replace"))
	b'string?'
	print(bytes("string\uFFFD", "ср1251", "ignore"))
	b'string'
</pre>
<p>♦ с помощью строкового метода <b>encode([encoding="utf-8"] · [, errors="strict"] )</b> • В параметре encoding задается кодировка (по умолчанию UTF-8). В параметре errors могут быть указаны значения <b>"strict"</b> (значение по умолчанию), <b>"replace", "ignore"</b>,
"xmlcharrefreplace" или "backslashreplace". Примеры:</p>
<pre>
	print("строка".еnсоdе())
	b'\xdl\x81\xdl\x82\xdl\x80\xdO\xЬe\xd0\xЬa\xd0\xЬO'
	print("cтpoкa".encode(encoding="cp1251"))
	b'\xfl\xf2\xf0\xee\xea\xe0'
	print(cтpoкa\uFFFD".encode(encoding="cp1251", errors="xmlcharrefreplace"))
	b'c\xf2po\xeaa&#65533;'
	print("cтpoкa\uFFFD" .encode(encoding="cp1251", errors="backslashreplace"))
	b'\xfl\xf2\xf0\xee\xea\xe0\\ufffd'
</pre>
<p>♦ указав букву b (регистр не имеет значения) перед строкой в апострофах, кавычках, тройных апострофах или тройных кавычках. В строке могут присутствовать только символы из кодировки ASCII, все остальные символы должны быть представлены специальными последовательностями. Примеры:</p>
<pre>
	print(b"string", b'string', b"""string""", b'''string''')
	(b'string', b'string', b'string', b'string')
	print(b"строка")
	SyntaxError: bytes can only contain ASCII literal characters.
	print(b"\xfl\xf2\xf0\xee\xea\xe0")
	b'\xfl\xf2\xf0\xee\xea\xe0'
</pre>
<p>♦ с помощью функции <b>bytes(<Последовательность>),</b> которая преобразует заданную последовательность целых чисел от О до 255 в объект типа <b>bytes</b>. Если какое-либо число из последовательности не попадает в диапазон, возбуждается исключение <b>valueError</b>. Примеры:
</p>
<pre>
	b = bytes([225, 226, 224, 174, 170, 160])
	print(b)
	b'\xel\xe2\xe0\xae\xaa\xa0'
	print(str(b, "ср866"))
	'строка'
</pre>
<p>♦ с помощью функции <b>bytes(<Количество>),</b> которая возвращает последовательность иззаданного количества нулевых элементов:</p>
<pre>
	print(bytes(10))
	b'\х00\х00\х00\х00\х00\х00\х00\х00\х00\х00'
</pre>
<p>♦ с помощью метода <b>bytes.fromhex(<Строка>).</b> Заданная строка в этом случае должна содержать только шестнадцатеричные числа. Начиная с Python 3. 7, числа в строке можно разделять пробелами, которые будут проигнорированы. Пример:</p>
<pre>
	b = bytes.fromhex(" el е2е0ае аааО ")
	print(b)
	b'\xel\xe2\xe0\xae\xaa\xa0'
	print(str(b, "ср866"))
	'строка'
</pre>
<p>Как и все последовательности, значения типа <b>bytes</b> поддерживают обращение к элементу по индексу, получение среза, конкатенацию, повторение и проверку на вхождение, при выводе значения целиком, а также при извлечении среза производится попытка.,,отображения символов. Однако доступ по индексу возвращает целое число, а не символ. Если преобразовать объект в список, то мы получим последовательность целых чисел. Тип bytes относится к неизменяемым типам. Это означает, что можно получить значение
по индексу, но изменить его нельзя.
	Объекты типа bytes поддерживают большинство строковых методов, рассмотренных в предыдущих разделах, за исключением <b>encode(), isidentifier(), isprintaЫe(), isnumeric(), isdecimal(), format_map(), format()</b> и операции форматирования. При использовании этих
методов следует учитывать, что в параметрах нужно указывать объекты типа bytes, а не строки, например:</p>
<pre>
	b = bytes("string", "ср1251")
	print(b.replace(b"s", b"S"))
	b'String
</pre>
<p>Смешивать строки и значения типа <b>bytes</b> в выражениях нельзя. Необходимо явно преобразовать объекты к одному типу, и лишь затем производить операцию, например:</p>
<pre>
	b"string" + "string"
	Traceback (most recent call last):
		File "<pyshell#79>", line 1, in <module>
			b"string" + "string"
	TypeError: can't concat bytes to str
	print(b"string" + "string".encode("ascii"))
	b'stringstring'
</pre>
<p>Значение типа <b>bytes</b> может содержать как однобайтовые, так и многобайтовые символы. При использовании многобайтовых символов некоторые функции могут работать не так, как предполагалось, - например, функция <b>len()</b> вернет количество байтов, а не символов:</p>
<pre>
	lеn("строка")
	6
	len(bytes("cтpoкa", "ср1251"))
	6
	len(bytes("cтpoкa", "utf-8"))
	12
</pre>
<p>Преобразовать значение типа <b>bytes</b> в строку позволяет метод <b>decode()</b>. Метод имеет следующий формат:</p>
<pre>
	decode([encoding="utf-8"] [, errors="strict"])
</pre>
<p>Параметр <b>encoding</b> задает кодировку символов (по умолчанию UTF-8) в текущей последовательности, а параметр <b>errors </b>- способ обработки ошибок при преобразовании: <b>"strict"</b> (значение по умолчанию), <b>"replace"</b> или <b>"ignore"</b>. Пример преобразования:</p>
<pre>
	b = bytes("строка", "ср1251")
	print(b.decode(encoding="cp1251"))
	'строка'
</pre>
<p>Для преобразования также можно воспользоваться функцией <b>str():</b></p>
<pre>
	b = Ьуtеs("строка", "ср1251")
	print(str(Ь, "ср1251"))
	'строка'
</pre>
<p>Чтобы изменить кодировку данных, сначала следует преобразовать значение типа <b>bytes </b>в строку, а затем произвести обратное преобразование, указав нужную кодировку. Преобра зуем данные из кодировки <b>Windows-1251</b> в кодировку <b>KOI8-R</b>, а затем обратно:</p>
<pre>
	w = Ьуtеs("Строка", "ср1251") # Данные в кодировке windows-1251
	k = w.decode("cp1251") .encode("koi8-r")
	# Данные в кодировке KOI8-R
	print(k, str(k, "koi8-r"))
	(b'\xf3\xd4\xd2\xcf\xcb\xcl', 'Строка')
	w = k.decode("koi8-r").encode("cp1251")
	print(w, str(w, "ср1251"))    # Данные в кодировке windows-1251
	(b'\xdl\xf2\xf0\xee\xea\xe0', 'Строка')
</pre>

</span>
</body>
</html>