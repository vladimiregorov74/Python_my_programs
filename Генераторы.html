<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Генераторные выражения</title>
    <span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">
        <a href="./0_Помощь_Python.html">Помощь_Python.html</a></span></span>
  <hr>
<span style="font-size:26px;"><span style="font-family:arial,helvetica,sans-serif;">
    <hr id="a">
    <pre>
        <h1  id="a0"> 1.Определение и классификация&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

<h2   id="a1"> 1.1 Что и зачем&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

    Генераторы выражений предназначены для компактного и удобного способа генерации коллекций элементов, а также
преобразования одного типа коллекций в другой.
В процессе генерации или преобразования возможно применение условий и модификация элементов. Генераторы выражений
являются синтаксическим сахаром и не решают задач, которые нельзя было бы решить без их использования.


<h2   id="a2"> 1.2 Преимущества использования генераторов выражений&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

    Более короткий и удобный синтаксис, чем генерация в обычном цикле.
Более понятный и читаемый синтаксис чем функциональный аналог сочетающий одновременное применение функций <b>map(), filter() и lambda</b>.
В целом: быстрее набирать, легче читать, особенно когда подобных операций много в коде.


<h2   id="a3"> 1.3 Классификация и особенности&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Сразу скажу, что существует некоторая терминологическая путаница в русских названиях того, о чем мы будем говорить.

В данной статье используются следующие обозначения:

    выражение-генератор (generator expression) — выражение в круглых скобках которое выдает создает на каждой итерации новый элемент по правилам.
    генератор коллекции — обобщенное название для генератора списка (list comprehension), генератора словаря (dictionary comprehension) и генератора множества (set comprehension).


<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/gen1.png" alt="Just image">

В отдельных местах, чтобы избежать нагромождения терминов, будет использоваться термин «генератор» без дополнительных
уточнений.
       <h1   id="a4"> 2. Синтаксис&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

Для начала приведем иллюстрацию общего синтаксиса выражения-генератора.
        <b>Важно</b>: этот синтаксис одинаков и для выражения-генератора и для всех трех типов генераторов коллекций,
разница заключается, в каких скобках он будет заключен (смотрите предыдущую иллюстрацию).


<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/gen2.png" alt="Just image">

Общие принципы важные для понимания:

    <b>Ввод</b> — это итератор — это может быть функция-генератор, выражение-генератор, коллекция — любой объект поддерживающий
        итерацию по нему.
    <b>Условие</b> — это фильтр при выполнении которого элемент пойдет в финальное выражение, если элемент ему не удовлетворяет,
        он будет пропущен.
    <b>Финальное выражение</b> — преобразование каждого выбранного элемента перед его выводом или просто вывод без изменений.


    <h2   id="a5"> 2.1 Базовый синтаксис&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>
    <span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]    # Пусть у нас есть исходный список
    list_b = [x for x in list_a]           # Создадим новый список используя генератор списка
    print(list_b)                          # [-2, -1, 0, 1, 2, 3, 4, 5]
    print(list_a is list_b)                # False - это разные объекты!</span>


По сути, ничего интересного тут не произошло, мы просто получили копию списка. Делать такие копии или просто перегонять
коллекции из типа в тип с помощью генераторов особого смысла нет — это можно сделать значительно проще применив
соответствующие методы или функции создания коллекций (рассматривались в первой статье цикла).

Мощь генераторов выражений заключается в том, что мы можем задавать условия для включения элемента в новую коллекцию и
можем делать преобразование текущего элемента с помощью выражения или функции перед его выводом (включением в новую
коллекцию).

    <h2   id="a6"> 2.2 Добавляем условие для фильтрации&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

<b>Важно</b>: Условие проверяется на каждой итерации, и только элементы ему удовлетворяющие идут в обработку в выражении.

Добавим в предыдущий пример условие — брать только четные элементы.
<span style="color: #0000ff;">
    # if x % 2 == 0 - остаток от деления на 2 равен нулю - число четное
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_b = [x for x in list_a if x % 2 == 0]
    print(list_b)   # [-2, 0, 2, 4]
</span>

Мы можем использовать несколько условий, комбинируя их логическими операторами:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_b = [x for x in list_a if x % 2 == 0 and x > 0]
    # берем те x, которые одновременно четные и больше нуля
    print(list_b)   # [2, 4]
</span>

    <h2   id="a7"> 2.3 Добавляем обработку элемента в выражении&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Мы можем вставлять не сам текущий элемент, прошедший фильтр, а результат вычисления выражения с ним или результат его
обработки функцией.

<b>Важно</b>: Выражение выполняется независимо на каждой итерации, обрабатывая каждый элемент индивидуально.

Например, можем посчитать квадраты значений каждого элемента:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_b = [x**2 for x in list_a]
    print(list_b)   # [4, 1, 0, 1, 4, 9, 16, 25]
</span>

Или посчитать длины строк c помощью функции <b>len()</b>
<span style="color: #0000ff;">
list_a = ['a', 'abc', 'abcde']
list_b = [len(x) for x in list_a]
print(list_b)   # [1, 3, 5]
</span>

    <h2   id="a8"> 2.4 Ветвление выражения&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

<b>Обратите внимание</b>: Мы можем использовать (начиная с Python 2.5) в выражении конструкцию <b>f-else</b>i для ветвления финального
выражения.

В таком случае:

    Условия ветвления пишутся не после, а перед итератором.
    В данном случае <b>if-else</b> это не фильтр перед выполнением выражения, а ветвление самого выражения, то есть переменная
уже прошла фильтр, но в зависимости от условия может быть обработана по-разному!
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_b = [x if x < 0 else x**2 for x in list_a]
    # Если x-отрицательное - берем x, в остальных случаях - берем квадрат x
    print(list_b)   # [-2, -1, 0, 1, 4, 9, 16, 25]
</span>

Никто не запрещает комбинировать фильтрацию и ветвление:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_b = [x**3 if x < 0 else x**2 for x in list_a if x % 2 == 0]
    # вначале фильтр пропускает в выражение только четные значения
    # после этого ветвление в выражении для отрицательных возводит в куб, а для остальных в квадрат
    print(list_b)   # [-8, 0, 4, 16]
</span>

Этот же пример в виде цикла
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_b = []
    for x in list_a:
        if x % 2 == 0:
            if x < 0:
                list_b.append(x ** 3)
            else:
                list_b.append(x ** 2)
    print(list_b)   # [-8, 0, 4, 16]
</span>
    <h2   id="a10"> 2.5 Улучшаем читаемость&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Не забываем, что в Python синтаксис позволяет использовать переносы строк внутри скобок. Используя эту возможность,
можно сделать синтаксис генераторов выражений более легким для чтения:
<span style="color: #0000ff;">
    numbers = range(10)
    # Before
    squared_evens = [n ** 2 for n in numbers if n % 2 == 0]
    # After
    squared_evens = [
        n ** 2
        for n in numbers
        if n % 2 == 0
    ]
</span>

    <h1   id="a11"> 3. Аналоги в виде цикла for и в виде функций&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

Как уже говорилось выше, задачи решаемые с помощью генераторов выражений можно решить и без них. Приведем другие подходы,
которые могут быть использованы для решения тех же задач.

Для примера возьмем простую задачу — сделаем из списка чисел список квадратов четных чисел и решим ее с помощью трех
разных подходов:

    <h2   id="a12"> 3.1 Решение с помощью генератора списка&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>
<span style="color: #0000ff;">
    numbers = range(10)
    squared_evens = [n ** 2 for n in numbers if n % 2 == 0]
    print(squared_evens)   # [0, 4, 16, 36, 64]
</span>

<h2   id="a13"> 3.2. Решение c помощью цикла for&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

<b>Важно</b>: Каждый генератор выражений можно переписать в виде цикла <b>for</b>, но не каждый цикл <b>for</b> можно представить в виде такого выражения.
<span style="color: #0000ff;">
    numbers = range(10)
    squared_evens = []
    for n in numbers:
        if n % 2 == 0:
            squared_evens.append(n ** 2)
    print(squared_evens)   # [0, 4, 16, 36, 64]
</span>

В целом, для очень сложных и комплексных задач, решение в виде цикла может быть понятней и проще в поддержке и
доработке. Для более простых задач, синтаксис выражения-генератора будет компактней и легче в чтении.

    <h2   id="a14"> 3.3. Решение с помощью функций.&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Для начала, замечу, что выражение генераторы и генераторы коллекций — это тоже функциональный стиль, но более новый и
предпочтительный.

Можно применять и более старые функциональные подходы для решения тех же задач, комбинируя <b>map(), lambda и filter()</b>.
<span style="color: #0000ff;">
    numbers = range(10)
    squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
    print(squared_evens)         # <<map object at 0x7f661e5dba20>>
    print(list(squared_evens))   # [0, 4, 16, 36, 64]</span>

# Примечание: в Python 2 в переменной squared_evens окажется сразу список, а в Python 3 «map object», который мы
        превращаем в список с помощью <b>list()</b>


Несмотря на то, что подобный пример вполне рабочий, читается он тяжело и использование синтаксиса генераторов выражений
будет более предпочительным и понятным.

    <h1   id="a15"> 4. Выражения-генераторы&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

Выражения-генераторы (generator expressions) доступны, начиная с Python 2.4. Основное их отличие от генераторов
коллекций в том, что они выдают элемент по-одному, не загружая в память сразу всю коллекцию.

UPD: Еще раз обратите внимание на этот момент: если мы создаем большую структуру данных без использования генератора,
то она загружается в память целиком, соответственно, это увеличивает расход памяти Вашим приложением, а в крайних
случаях памяти может просто не хватить и Ваше приложение «упадет» с MemoryError. В случае использования
выражения-генератора, такого не происходит, так как элементы создаются по-одному, в момент обращения.

Пример выражения-генератора:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_gen = (i for i in list_a)    # выражение-генератор
    print(next(my_gen))     # -2 - получаем очередной элемент генератора
    print(next(my_gen))     # -1 - получаем очередной элемент генератора
</span>

Особенности выражений-генераторов

    Генаратор нельзя писать без скобок — это синтаксическая ошибка.
<span style="color: #0000ff;">
    # my_gen = i for i in list_a      # SyntaxError: invalid syntax
</span>

    При передаче в функцию дополнительные скобки необязательны
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_sum = sum(i for i in list_a)
    # my_sum = sum((i for i in list_a))  # так тоже можно
    print(my_sum)   # 12
</span>

    Нельзя получить длину функцией <b>len()</b>
<span style="color: #0000ff;">
    # my_len = len(i for i in list_a)  # TypeError: object of type 'generator' has no <b>len()</b>
</span>

    Нельзя распечатать элементы функцией <b>print()</b>
<span style="color: #0000ff;">
    print(my_gen)   # <<generator object <<genexpr>> at 0x7f162db32af0>
</span>

    Обратите внимание, что после прохождения по выражению-генератору оно остается пустым!
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_gen = (i for i in list_a)
    print(sum(my_gen))  # 12
    print(sum(my_gen))  # 0
</span>

    Выражение-генератор может быть бесконечным.
<span style="color: #0000ff;">
    import itertools
    inf_gen = (x for x in itertools.count())  # бесконечный генератор от 0 to бесконечности!
</span>
    Будьте осторожны в работе с такими генераторами, так как при не правильном использовании «эффект» будет как от
бесконечного цикла.

    К выражению-генератору не применимы срезы!
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_gen = (i for i in list_a)
    my_gen_sliced = my_gen[1:3]
    # TypeError: 'generator' object is not subscriptable
</span>
    Но
    <span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_list = [i for i in list_a][1:3]
    print(my_list)  # [-1, 0]
    </span>
    Из генератора легко получать нужную коллекцию. Это подробно рассматривается в следующей главе.


    <h1   id="a16"> 5. Генерация стандартных коллекций&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

    <h2   id="a17"> 5.1 Создание коллекций из выражения-генератора&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Создание коллекций из выражения-генератора с помощью функций <b>list(), tuple(), set(), frozenset()</b>

<b>Примечание</b>: Так можно создать и неизменное множество и кортеж, так как неизменными они станет уже после генерации.

<b>Внимание</b>: Для строки такой способ не работает! Синтаксис создания генератора словаря таким образом имеет свои
особенности, он рассмотрен в следующем под-разделе.

    1.Передачей готового выражения-генератора присвоенного переменной в функцию создания коллекции.
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_gen = (i for i in list_a)   # выражение-генератор
    my_list = list(my_gen)
    print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
</span>

   2. Написание выражения-генератора сразу внутри скобок вызываемой функции создания коллекции.
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_list = list(i for i in list_a)
    print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
</span>
То же самое для кортежа, множества и неизменного множества
<span style="color: #0000ff;">
    # кортеж
    my_tuple = tuple(i for i in list_a)
    print(my_tuple)         # (-2, -1, 0, 1, 2, 3, 4, 5)

    # множество
    my_set = set(i for i in list_a)
    print(my_set)           # {0, 1, 2, 3, 4, 5, -1, -2}

    # неизменное множество
    my_frozenset = frozenset(i for i in list_a)
    print(my_frozenset)     # frozenset({0, 1, 2, 3, 4, 5, -1, -2})
</span>
    <h2   id="a18"> 5.2 Специальный синтаксис генераторов коллекций&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

В отличии от выражения-генератора, которое выдает значение по-одному, не загружая всю коллекцию в память, при
использовании генераторов коллекций, коллекция генерируется сразу целиком.

Соответственно, вместо особенности выражений-генераторов перечисленных выше, такая коллекция будет обладать всеми
стандартными свойствами характерными для коллекции данного типа.

Обратите внимание, что для генерации множества и словаря используются одинаковые скобки, разница в том, что у словаря
указывается двойной элемент ключ: значение.

    Генератор списка (list comprehension)
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_list = [i for i in list_a]
    print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
</span>

    Не пишите круглые скобки в квадратных!
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_list = [(i for i in list_a)]
    print(my_list)          # [<generator object <<genexpr>> at 0x7fb81103bf68>]
</span>

    Генератор множества (set comprehension)
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    my_set= {i for i in list_a}
    print(my_set)       # {0, 1, 2, 3, 4, 5, -1, -2} - порядок случаен
</span>

    Генератор словаря (dictionary comprehension)
    переворачивание словаря
<span style="color: #0000ff;">
    dict_abc = {'a': 1, 'b': 2, 'c': 3, 'd': 3}
    dict_123 = {v: k for k, v in dict_abc.items()}
    print(dict_123)  # {1: 'a', 2: 'b', 3: 'd'}
                     # Обратите внимание, мы потеряли "с"! Так как значения были одинаковы,
                     # то когда они стали ключами, только последнее значение сохранилось.
</span>

    Словарь из списка:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    dict_a = {x: x**2 for x in list_a}
    print(dict_a)   # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, -2: 4, -1: 1, 5: 25}
</span>

    <b>Важно!</b> Такой синтаксис создания словаря работает только в фигурных скобках, выражение-генератор так создать нельзя,
для этого используется немного другой синтаксис (благодарю longclaps за подсказку в комментариях):
<span style="color: #0000ff;">
    # dict_gen = (x: x**2 for x in list_a)      # SyntaxError: invalid syntax
    dict_gen = ((x, x ** 2) for x in list_a)    # Корректный вариант генератора-выражения для словаря
    # dict_a = dict(x: x**2 for x in list_a)    # SyntaxError: invalid syntax
    dict_a = dict((x, x ** 2) for x in list_a)  # Корректный вариант синтаксиса от @longclaps
</span>

    <h2   id="a19"> 5.3 Генерация строк&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Для создания строки вместо синтаксиса выражений-генераторов используется метод строки <b>.join()</b>, которому в качестве
аргументов можно передать выражение генератор.
Обратите внимание: элементы коллекции для объединения в строку должны быть строками!
<span style="color: #0000ff;">
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    # используем генератор прямо в .join() одновременно приводя элементы к строковому типу
    my_str = ''.join(str(x) for x in list_a)
    print(my_str)  # -2-1012345
</span>

    <h1   id="a20"> 6. Периодичность и частичный перебор&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

    <h2   id="a21"> 6.1 Работа с enumerate()&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Иногда в условиях задачи в условии-фильтре нужна не проверка значения текущего элемента, а проверка на определенную
периодичность, то есть, например, нужно брать каждый третий элемент.

Для подобных задач можно использовать функцию <b>enumerate()</b>, задающую счетчик при обходе итератора в цикле:
<span style="color: #0000ff;">
    for i, x in enumerate(iterable)
</span>
здесь x — текущий элемент i — его порядковый номер, начиная с нуля

Проиллюстрируем работу с индексами:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_d = [(i, x) for i, x in enumerate(list_a)]
    print(list_d)   # [(0, -2), (1, -1), (2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)]
</span>

Теперь попробуем решить реальную задачу — выберем в генераторе списка каждый третий элемент из исходного списка:
<span style="color: #0000ff;">
    list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
    list_e = [x for i, x in enumerate(list_a, 1) if i % 3 == 0]
    print(list_e)   # [0, 3]
</span>

Важные особенности работы функции <b>enumerate()</b>:

    Возможны два варианта вызова функции <b>enumerate()</b>:
       <b>enumerate(iterator)</b> без второго параметра считает с 0.
        <b>enumerate(iterator, start)</b> — начинает считать с значения <b>start</b>. Удобно, например, если нам надо считать с 1,
                                    а не 0.

    <b>enumerate()</b> возвращает кортеж из порядкового номера и значения текущего элемента итератора. Кортеж в
    выражении-генераторе результате можно получить двумя способами:
        <b>(i, j) for i, j in enumerate(iterator)</b> — скобки в первой паре нужны!
        <b>pair for pair in enumerate(mylist)</b> — мы работаем сразу с парой

    Индексы считаются для всех обработанных элементов, без учета прошли они в дальнейшем условие или нет!
<span style="color: #0000ff;">
    first_ten_even = [(i, x) for i, x in enumerate(range(10)) if x % 2 == 0]
    print(first_ten_even)   # [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)]
</span>

    Функция <b>enumerate()</b> не обращается к каким-то внутренним атрибутам коллекции, а просто реализует счетчик обработанных
элементов, поэтому ничего не мешает ее использовать для неупорядоченных коллекций не имеющих индексации.

    Если мы ограничиваем количество элементов включенных в результат по <b>enumerate()</b> счетчику (например <b>if i < 10</b>), то
итератор будет все равно обработан целиком, что в случае огромной коллекции будет очень ресурс-затратно. Решение этой
проблемы рассматривается ниже в под-разделе «Перебор части итерируемого».


    <h2   id="a22"> 6.2 Перебор части итерируемого.&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Иногда бывает задача из очень большой коллекции или даже бесконечного генератора получить выборку первых нескольких
элементов, удовлетворяющих условию.

Если мы используем обычное генераторное выражение с условием ограничением по <b>enumerate()</b> индексу или срез полученной
результирующей коллекции, то нам в любом случае придется пройти всю огромную коллекцию и потратить на это уйму
компьютерных ресурсов.

Выходом может быть использование функции <b>islice()</b> из пакета <b>itertools</b>.
<span style="color: #0000ff;">
    import itertools
    first_ten = (itertools.islice((x for x in range(1000000000) if x % 2 == 0), 10))
    print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
</span>
Для сомневающихся: проверяем время выполнения
<span style="color: #0000ff;">
    import time
    import itertools

    # На генераторе с малым количеством элементов
    start_time = time.time()
    first_ten = (itertools.islice((x for x in range(100) if x % 2 == 0), 10))
    print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
    elapsed_time = time.time() - start_time
    print(elapsed_time)  # 3.409385681152344e-05

    # На генераторе с огромным количеством элементов
    start_time = time.time()
    first_ten = (itertools.islice((x for x in range(100000000) if x % 2 == 0), 10))
    print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
    elapsed_time = time.time() - start_time
    print(elapsed_time)  # 1.1205673217773438e-05

    # То есть максимальное количество элементов в генераторе <b>range()</b> мы увеличили на 6 порядков,
    # а время исполнения осталось того же порядка
</span>

    <h2   id="a23"> 7. Вложенные циклы и генераторы&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Рассмотрим более комплексные варианты, когда у нас циклы или сами выражения-генераторы являются вложенными. Тут возможны
несколько вариантов, со своими особенностями и сферой применения, чтобы не возникало путаницы, рассмотрим их
по-отдельности, а после приведем общую схему.

<h2   id="a24"> 7.1 Вложенные циклы&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

В результате генерации получаем одномерную структуру.

<b>Важно!</b> При работае с вложенными циклами внутри генератора выражений порядок следования инструкций <b>for in</b> будет такой же
слева-направо), как и в аналогичном решении без генератора, только на циклах (сверху-вниз)! Тоже справедливо и при более
глубоких уровнях вложенности.

<h2   id="a25"> 7.1.1 Вложенные циклы for где циклы идут по независимым итераторам&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Общий синтаксис: <b>[expression for x in iter1 for y in iter2]</b>
Применение: генерируем одномерную структуру, используя данные из двух итераторов.

Например, создадим словарь, используя кортежи координат как ключи, заполнив для начала его значения нулями.
<span style="color: #0000ff;">
    rows = 1, 2, 3
    cols = 'a', 'b'
    my_dict = {(col, row): 0 for row in rows for col in cols}
    print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
</span>

Дальше можем задавать новые значения или получать их

Тоже можно сделать и с дополнительными условиями-фильтрами в каждом цикле:
<span style="color: #0000ff;">
    rows = 1, 2, 3, -4, -5
    cols = 'a', 'b', 'abc'
    # Для наглядности разнесем на несколько строк
    my_dict = {
        (col, row): 0  # каждый элемент состоит из ключа-кортежа и нулевого знаечния
        for row in rows if row > 0   # Только положительные значения
        for col in cols if len(col) == 1  # Только односимвольные
        }
    print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
</span>

Эта же задача решенная с помощью цикла
<span style="color: #0000ff;">
    rows = 1, 2, 3, -4, -5
    cols = 'a', 'b', 'abc'
    my_dict = {}
    for row in rows:
        if row > 0:
            for col in cols:
                if len(col) == 1:
                    my_dict[col, row] = 0
    print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
</span>

    <h2   id="a26"> 7.1.2 Вложенные циклы for где внутренний цикл идет по результату внешнего цикла&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Общий синтаксис:<b>[expression for x in iterator for y in x]</b> .

Применение: Стандартный подход, когда нам надо обходить двумерную структуру данных, превращая ее в «плоскую» одномерную.
В данном случае, мы во внешнем цикле проходим по строкам, а во внутреннем по элементам каждой строки нашей двумерной структуры.

Допустим у нас есть двумерная матрица — список списков. И мы желаем преобразовать ее в плоский одномерный список.
<span style="color: #0000ff;">
    matrix = [[0, 1, 2, 3],
              [10, 11, 12, 13],
              [20, 21, 22, 23]]

    # Решение с помощью генератора списка:
    flattened = [n for row in matrix for n in row]
    print(flattened)    # [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]
</span>

Таже задача, решенная с помощью вложенных циклов
<span style="color: #0000ff;">
    flattened = []
    for row in matrix:
        for n in row:
            flattened.append(n)
    print(flattened)
</span>
UPD:Изящные решения из комментариев
<span style="color: #0000ff;">
    import itertools
    flattened = list(itertools.chain.from_iterable(matrix))  # от @iMrDron
    # Данный подходнамного быстрее генератора списков
    # и рекомендован к использованию для подобных задач.

    flattened = sum(a, [])  # от @YuriM1983
    # sum(a, []) имеет квадратическую сложность(O(n^2))
    # и потому совсем не рекомендуется к использованию для таких целей
</span>
    <h2   id="a27"> 7.2 Вложенные генераторы&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Вложенными могут быть не только циклы for внутри выражения-генератора, но и сами генераторы.
Такой подход применяется когда нам надо строить двумерную структуру.

<b>Важно!</b>: В отличии от примеров выше с вложенными циклами, для вложенных генераторов, вначале обрабатывается
внешний генератор, потом внутренний, то есть порядок идет справа-налево.

Ниже рассмотрим два варианта подобного использования.

    <h2   id="a28"> 7.2.1 — Вложенный генератор внутри генератора — двумерная из двух одномерных&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Общий синтаксис: <b>[[expression for y in iter2] for x in iter1]</b>
Применение: генерируем двумерную структуру, используя данные из двух одномерных итераторов.

Для примера создадим матрицу из 5 столбцов и 3 строк и заполним ее нулями:
<span style="color: #0000ff;">
    w, h = 5, 3  # зададим ширину и высотку матрицы
    matrix = [[0 for x in range(w)] for y in range(h)]
    print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
</span>

Создание этой же матрицы двумя вложенными циклами - обратите внимание на порядок вложения
<span style="color: #0000ff;">
    matrix = []
    for y in range(h):
        new_row = []
        for x in range(w):
            new_row.append(0)
        matrix.append(new_row)
    print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
</span>

<b>Примечание</b>: После создания можем работать с матрицей как с обычным двумерным массивом
<span style="color: #0000ff;">
# теперь можно добавлять значения по координатам (координаты - индексы в списке списков)
matrix[0][0] = 1
matrix[1][3] = 3
print(matrix)   # [[1, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0]]

# Получаем значение по произвольным координатам
x, y = 1, 3
print(matrix[x][y])  # 3
</span>

    <h2   id="a29"> 7.2.2 — Вложенный генератор внутри генератора — двумерная из двумерной&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Общий синтаксис: <b>[[expression for y in x] for x in iterator]</b>
Применение: Обходим двумерную структуру данных, сохраняя результат в другую двумерную структуру.

Возьмем матрицу:

<b>matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]</b>


Возведем каждый элемент матрицы в квадрат:

<b>squared = [[cell**2 for cell in row] for row in matrix]
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]</b>

    Эта же операция в виде вложенных циклов
<span style="color: #0000ff;">
squared = []
for row in matrix:
    new_row = []
    for cell in row:
        new_row.append(cell**2)
    squared.append(new_row)
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]
</span>

Обобщим все вышеперечисленные варианты в одной схеме (полный размер по клику):

<img src="file:///media/vladimir/Games+/Python_books/HTML/help/Resurs/gen3.png" alt="Just image">

    <h2   id="a30"> 7.3 — Генератор итерирующийся по генератору&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Так как любой генератор может использоваться как итератор в цикле for, это так же можно использовать и для создания
генератора по генератору. При этом синтаксически это может записываться в два выражения или объединяться во вложенный
генератор.

Проиллюстрирую и такую возможность.
Допустим у нас есть два таких генератора списков:
<span style="color: #0000ff;">
    list_a = [x for x in range(-2, 4)]    # Так сделано для дальнейшего примера синтаксиса,
                                          # конечно в подобной задаче досточно только range(-2, 4)
    list_b = [x**2 for x in list_a]
</span>

Тоже самое можно записать и в одно выражение, подставив вместо list_a его генератор списка:
<span style="color: #0000ff;">
    list_c = [x**2 for x in [x for x in range(-2, 4)]]
    print(list_c)  # [4, 1, 0, 1, 4, 9]
</span>

UPD : Преимущество от комбинирования генераторов на примере сложной функции f(x) = u(v(x))
<span style="color: #0000ff;">
    list_c = [t + t ** 2  for t in (x ** 3 + x ** 4 for x in range(-2, 4))]
</span>

    <h2   id="a31"> 8. Использование range()&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>

Говоря о способах генерации коллекций, нельзя обойти вниманием простую и очень удобную функцию <b>range()</b>, которая
предназначена для создания арифметических последовательностей.

Особенности функции <b>range()</b>:

    Наиболее часто функция <b>range()</b> применяется для запуска цикла <b>for</b> нужное количество раз. Например, смотрите генерацию матрицы в примерах выше.

    В Python 3 <b>range()</b> возвращает генератор, который при каждом к нему обращении выдает очередной элемент.

    Исполльзуемые параметры аналогичны таковым в срезах (кроме первого примера с одним параметром):

        <b>range(stop)</b> — в данном случае с 0 до stop-1;
        <b>range(start, stop)</b> — Аналогично примеру выше, но можно задать начало отличное от нуля, можно и отрицательное;
        <b>range(start, stop, step)</b> — Добавляем параметр шага, который может быть отрицательным, тогда перебор в обратном порядке.

    В Python 2 были 2 функции:

        <b>range(...)</b> которая аналогична выражению <b>list(range(...))</b> в Python 3 — то есть она выдавала не итератор, а
        сразу готовый список. То есть все проблемы возможной нехватки памяти, описанные в разделе 4 актуальны, и
        использовать ее в Python 2 надо очень аккуратно!
        <b>xrange(...) </b>— которая работала аналогично <b>range(...)</b> в Python 3 и из 3 версии была исключена.


Примеры использования:
<span style="color: #0000ff;">
    print(list(range(5)))           # [0, 1, 2, 3, 4]
    print(list(range(-2, 5)))       # [-2, -1, 0, 1, 2, 3, 4]
    print(list(range(5, -2, -2)))   # [5, 3, 1, -1]
</span>

    <h1   id="a32"> 9. Приложение 1. Дополнительные примеры&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h1>

    <h2   id="a33"> 9.1 Последовательный проход по нескольким спискам&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>
<span style="color: #0000ff;">
    import itertools
    l1 = [1,2,3]
    l2 = [10,20,30]
    result = [l*2 for l in itertools.chain(l1, l2)]
    print(result)   # [2, 4, 6, 20, 40, 60]
</span>

    <h2   id="a34"> 9.2 Транспозиция матрицы&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>
(Преобразование матрицы, когда строки меняются местами со столбцами).

Возьмем матрицу.
<span style="color: #0000ff;">
    matrix = [[1, 2, 3, 4],
              [5, 6, 7, 8],
              [9, 10, 11, 12]]
</span>

Сделаем ее транспозицию с помощью генератора выражений:
<span style="color: #0000ff;">
    transposed = [[row[i] for row in matrix] for i in range(len(matrix[0]))]
    print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</span>

Эта же транспозиция матрицы в виде цикла
<span style="color: #0000ff;">
    transposed = []
    for i in range(len(matrix[0])):
        new_row = []
        for row in matrix:
            new_row.append(row[i])
        transposed.append(new_row)
    print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</span>

И немного черной магии
<span style="color: #0000ff;">
    transposed = list(map(list, zip(*matrix)))
    print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</span>

    <h2   id="a35"> 9.3 Задача выбора только рабочих дней&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a">Up</a></h2>
<span style="color: #0000ff;">
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

# Делим список дней на недели
weeks = [days[i:i+7] for i in range(0, len(days), 7)]
print(weeks)   # [[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21],
        [22, 23, 24, 25, 26, 27, 28], [29, 30, 31]]

# Выбираем в каждой неделе только первые 5 рабочих дней, отбрасывая остальные
work_weeks = [week[0:5] for week in weeks]
print(work_weeks)   # [[1, 2, 3, 4, 5], [8, 9, 10, 11, 12], [15, 16, 17, 18, 19], [22, 23, 24, 25, 26], [29, 30, 31]]

# Если нужно одним списком дней - можно объединить
wdays = [item for sublist in work_weeks for item in sublist]
print(wdays)   # [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]
</span>

Можно убрать выходные еще более изящно, используя только индексы
<span style="color: #0000ff;">
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

wdays6 = [wd for (i, wd) in enumerate(days, 1) if i % 7 != 0]  # Удаляем каждый 7-й день
# Удаляем каждый 6 день в оставшихся после первого удаления:
wdays5 = [wd for (i, wd) in enumerate(wdays6, 1) if i % 6 != 0]

print(wdays5)
# [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]

# Обратите внимание, что просто объединить два условия в одном if не получится,
# как минимум потому, что 12-й день делится на 6, но не выпадает на последний 2 дня недели!

# Шикарное короткое решение:
days = [d + 1 for d in range(31) if d % 7 < 5]
</span>


    </pre></span>
</head>
<body>

</body>
</html>